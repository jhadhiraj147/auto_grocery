// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MESSAGES_AUTO_GROCERY_FB_H_
#define FLATBUFFERS_GENERATED_MESSAGES_AUTO_GROCERY_FB_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 19,
             "Non-compatible flatbuffers version included");

namespace auto_grocery {
namespace fb {

struct Item;
struct ItemBuilder;

struct TaskMessage;
struct TaskMessageBuilder;

enum MessageType : int8_t {
  MessageType_FETCH_TASK = 0,
  MessageType_RESTOCK_TASK = 1,
  MessageType_ANALYTICS_DATA = 2,
  MessageType_MIN = MessageType_FETCH_TASK,
  MessageType_MAX = MessageType_ANALYTICS_DATA
};

inline const MessageType (&EnumValuesMessageType())[3] {
  static const MessageType values[] = {
    MessageType_FETCH_TASK,
    MessageType_RESTOCK_TASK,
    MessageType_ANALYTICS_DATA
  };
  return values;
}

inline const char * const *EnumNamesMessageType() {
  static const char * const names[4] = {
    "FETCH_TASK",
    "RESTOCK_TASK",
    "ANALYTICS_DATA",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageType(MessageType e) {
  if (::flatbuffers::IsOutRange(e, MessageType_FETCH_TASK, MessageType_ANALYTICS_DATA)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessageType()[index];
}

struct Item FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ItemBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SKU = 4,
    VT_AISLE = 6,
    VT_QUANTITY = 8
  };
  const ::flatbuffers::String *sku() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SKU);
  }
  const ::flatbuffers::String *aisle() const {
    return GetPointer<const ::flatbuffers::String *>(VT_AISLE);
  }
  int32_t quantity() const {
    return GetField<int32_t>(VT_QUANTITY, 0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SKU) &&
           verifier.VerifyString(sku()) &&
           VerifyOffset(verifier, VT_AISLE) &&
           verifier.VerifyString(aisle()) &&
           VerifyField<int32_t>(verifier, VT_QUANTITY, 4) &&
           verifier.EndTable();
  }
};

struct ItemBuilder {
  typedef Item Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sku(::flatbuffers::Offset<::flatbuffers::String> sku) {
    fbb_.AddOffset(Item::VT_SKU, sku);
  }
  void add_aisle(::flatbuffers::Offset<::flatbuffers::String> aisle) {
    fbb_.AddOffset(Item::VT_AISLE, aisle);
  }
  void add_quantity(int32_t quantity) {
    fbb_.AddElement<int32_t>(Item::VT_QUANTITY, quantity, 0);
  }
  explicit ItemBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Item> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Item>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Item> CreateItem(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> sku = 0,
    ::flatbuffers::Offset<::flatbuffers::String> aisle = 0,
    int32_t quantity = 0) {
  ItemBuilder builder_(_fbb);
  builder_.add_quantity(quantity);
  builder_.add_aisle(aisle);
  builder_.add_sku(sku);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Item> CreateItemDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *sku = nullptr,
    const char *aisle = nullptr,
    int32_t quantity = 0) {
  auto sku__ = sku ? _fbb.CreateString(sku) : 0;
  auto aisle__ = aisle ? _fbb.CreateString(aisle) : 0;
  return auto_grocery::fb::CreateItem(
      _fbb,
      sku__,
      aisle__,
      quantity);
}

struct TaskMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TaskMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORDER_ID = 4,
    VT_TYPE = 6,
    VT_ITEMS = 8,
    VT_LATENCY_MS = 10,
    VT_SUCCESS = 12
  };
  const ::flatbuffers::String *order_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORDER_ID);
  }
  auto_grocery::fb::MessageType type() const {
    return static_cast<auto_grocery::fb::MessageType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<auto_grocery::fb::Item>> *items() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<auto_grocery::fb::Item>> *>(VT_ITEMS);
  }
  double latency_ms() const {
    return GetField<double>(VT_LATENCY_MS, 0.0);
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ORDER_ID) &&
           verifier.VerifyString(order_id()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.VerifyVectorOfTables(items()) &&
           VerifyField<double>(verifier, VT_LATENCY_MS, 8) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           verifier.EndTable();
  }
};

struct TaskMessageBuilder {
  typedef TaskMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_order_id(::flatbuffers::Offset<::flatbuffers::String> order_id) {
    fbb_.AddOffset(TaskMessage::VT_ORDER_ID, order_id);
  }
  void add_type(auto_grocery::fb::MessageType type) {
    fbb_.AddElement<int8_t>(TaskMessage::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_items(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<auto_grocery::fb::Item>>> items) {
    fbb_.AddOffset(TaskMessage::VT_ITEMS, items);
  }
  void add_latency_ms(double latency_ms) {
    fbb_.AddElement<double>(TaskMessage::VT_LATENCY_MS, latency_ms, 0.0);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(TaskMessage::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit TaskMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TaskMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TaskMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TaskMessage> CreateTaskMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> order_id = 0,
    auto_grocery::fb::MessageType type = auto_grocery::fb::MessageType_FETCH_TASK,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<auto_grocery::fb::Item>>> items = 0,
    double latency_ms = 0.0,
    bool success = false) {
  TaskMessageBuilder builder_(_fbb);
  builder_.add_latency_ms(latency_ms);
  builder_.add_items(items);
  builder_.add_order_id(order_id);
  builder_.add_success(success);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TaskMessage> CreateTaskMessageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *order_id = nullptr,
    auto_grocery::fb::MessageType type = auto_grocery::fb::MessageType_FETCH_TASK,
    const std::vector<::flatbuffers::Offset<auto_grocery::fb::Item>> *items = nullptr,
    double latency_ms = 0.0,
    bool success = false) {
  auto order_id__ = order_id ? _fbb.CreateString(order_id) : 0;
  auto items__ = items ? _fbb.CreateVector<::flatbuffers::Offset<auto_grocery::fb::Item>>(*items) : 0;
  return auto_grocery::fb::CreateTaskMessage(
      _fbb,
      order_id__,
      type,
      items__,
      latency_ms,
      success);
}

inline const auto_grocery::fb::TaskMessage *GetTaskMessage(const void *buf) {
  return ::flatbuffers::GetRoot<auto_grocery::fb::TaskMessage>(buf);
}

inline const auto_grocery::fb::TaskMessage *GetSizePrefixedTaskMessage(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<auto_grocery::fb::TaskMessage>(buf);
}

template <bool B = false>
inline bool VerifyTaskMessageBuffer(
    ::flatbuffers::VerifierTemplate<B> &verifier) {
  return verifier.template VerifyBuffer<auto_grocery::fb::TaskMessage>(nullptr);
}

template <bool B = false>
inline bool VerifySizePrefixedTaskMessageBuffer(
    ::flatbuffers::VerifierTemplate<B> &verifier) {
  return verifier.template VerifySizePrefixedBuffer<auto_grocery::fb::TaskMessage>(nullptr);
}

inline void FinishTaskMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<auto_grocery::fb::TaskMessage> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedTaskMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<auto_grocery::fb::TaskMessage> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace fb
}  // namespace auto_grocery

#endif  // FLATBUFFERS_GENERATED_MESSAGES_AUTO_GROCERY_FB_H_
