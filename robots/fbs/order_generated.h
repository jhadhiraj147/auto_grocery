// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ORDER_ROBOTMESSAGES_H_
#define FLATBUFFERS_GENERATED_ORDER_ROBOTMESSAGES_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 19,
             "Non-compatible flatbuffers version included");

namespace RobotMessages {

struct Item;
struct ItemBuilder;

struct OrderBroadcast;
struct OrderBroadcastBuilder;

struct Item FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ItemBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SKU = 4,
    VT_QUANTITY = 6,
    VT_AISLE = 8
  };
  const ::flatbuffers::String *sku() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SKU);
  }
  int32_t quantity() const {
    return GetField<int32_t>(VT_QUANTITY, 0);
  }
  const ::flatbuffers::String *aisle() const {
    return GetPointer<const ::flatbuffers::String *>(VT_AISLE);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SKU) &&
           verifier.VerifyString(sku()) &&
           VerifyField<int32_t>(verifier, VT_QUANTITY, 4) &&
           VerifyOffset(verifier, VT_AISLE) &&
           verifier.VerifyString(aisle()) &&
           verifier.EndTable();
  }
};

struct ItemBuilder {
  typedef Item Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sku(::flatbuffers::Offset<::flatbuffers::String> sku) {
    fbb_.AddOffset(Item::VT_SKU, sku);
  }
  void add_quantity(int32_t quantity) {
    fbb_.AddElement<int32_t>(Item::VT_QUANTITY, quantity, 0);
  }
  void add_aisle(::flatbuffers::Offset<::flatbuffers::String> aisle) {
    fbb_.AddOffset(Item::VT_AISLE, aisle);
  }
  explicit ItemBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Item> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Item>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Item> CreateItem(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> sku = 0,
    int32_t quantity = 0,
    ::flatbuffers::Offset<::flatbuffers::String> aisle = 0) {
  ItemBuilder builder_(_fbb);
  builder_.add_aisle(aisle);
  builder_.add_quantity(quantity);
  builder_.add_sku(sku);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Item> CreateItemDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *sku = nullptr,
    int32_t quantity = 0,
    const char *aisle = nullptr) {
  auto sku__ = sku ? _fbb.CreateString(sku) : 0;
  auto aisle__ = aisle ? _fbb.CreateString(aisle) : 0;
  return RobotMessages::CreateItem(
      _fbb,
      sku__,
      quantity,
      aisle__);
}

struct OrderBroadcast FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OrderBroadcastBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORDER_ID = 4,
    VT_ORDER_TYPE = 6,
    VT_ITEMS = 8
  };
  const ::flatbuffers::String *order_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORDER_ID);
  }
  const ::flatbuffers::String *order_type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORDER_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<RobotMessages::Item>> *items() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<RobotMessages::Item>> *>(VT_ITEMS);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ORDER_ID) &&
           verifier.VerifyString(order_id()) &&
           VerifyOffset(verifier, VT_ORDER_TYPE) &&
           verifier.VerifyString(order_type()) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.VerifyVectorOfTables(items()) &&
           verifier.EndTable();
  }
};

struct OrderBroadcastBuilder {
  typedef OrderBroadcast Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_order_id(::flatbuffers::Offset<::flatbuffers::String> order_id) {
    fbb_.AddOffset(OrderBroadcast::VT_ORDER_ID, order_id);
  }
  void add_order_type(::flatbuffers::Offset<::flatbuffers::String> order_type) {
    fbb_.AddOffset(OrderBroadcast::VT_ORDER_TYPE, order_type);
  }
  void add_items(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<RobotMessages::Item>>> items) {
    fbb_.AddOffset(OrderBroadcast::VT_ITEMS, items);
  }
  explicit OrderBroadcastBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OrderBroadcast> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OrderBroadcast>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OrderBroadcast> CreateOrderBroadcast(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> order_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> order_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<RobotMessages::Item>>> items = 0) {
  OrderBroadcastBuilder builder_(_fbb);
  builder_.add_items(items);
  builder_.add_order_type(order_type);
  builder_.add_order_id(order_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<OrderBroadcast> CreateOrderBroadcastDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *order_id = nullptr,
    const char *order_type = nullptr,
    const std::vector<::flatbuffers::Offset<RobotMessages::Item>> *items = nullptr) {
  auto order_id__ = order_id ? _fbb.CreateString(order_id) : 0;
  auto order_type__ = order_type ? _fbb.CreateString(order_type) : 0;
  auto items__ = items ? _fbb.CreateVector<::flatbuffers::Offset<RobotMessages::Item>>(*items) : 0;
  return RobotMessages::CreateOrderBroadcast(
      _fbb,
      order_id__,
      order_type__,
      items__);
}

inline const RobotMessages::OrderBroadcast *GetOrderBroadcast(const void *buf) {
  return ::flatbuffers::GetRoot<RobotMessages::OrderBroadcast>(buf);
}

inline const RobotMessages::OrderBroadcast *GetSizePrefixedOrderBroadcast(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<RobotMessages::OrderBroadcast>(buf);
}

template <bool B = false>
inline bool VerifyOrderBroadcastBuffer(
    ::flatbuffers::VerifierTemplate<B> &verifier) {
  return verifier.template VerifyBuffer<RobotMessages::OrderBroadcast>(nullptr);
}

template <bool B = false>
inline bool VerifySizePrefixedOrderBroadcastBuffer(
    ::flatbuffers::VerifierTemplate<B> &verifier) {
  return verifier.template VerifySizePrefixedBuffer<RobotMessages::OrderBroadcast>(nullptr);
}

inline void FinishOrderBroadcastBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<RobotMessages::OrderBroadcast> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedOrderBroadcastBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<RobotMessages::OrderBroadcast> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace RobotMessages

#endif  // FLATBUFFERS_GENERATED_ORDER_ROBOTMESSAGES_H_
