// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: proto/inventory.proto
// Protobuf C++ Version: 6.33.4

#ifndef proto_2finventory_2eproto_2epb_2eh
#define proto_2finventory_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6033004
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_type_handler.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_proto_2finventory_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2finventory_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_proto_2finventory_2eproto;
}  // extern "C"
namespace inventory {
class CheckAvailabilityRequest;
struct CheckAvailabilityRequestDefaultTypeInternal;
extern CheckAvailabilityRequestDefaultTypeInternal _CheckAvailabilityRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CheckAvailabilityRequest_class_data_;
class CheckAvailabilityResponse;
struct CheckAvailabilityResponseDefaultTypeInternal;
extern CheckAvailabilityResponseDefaultTypeInternal _CheckAvailabilityResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CheckAvailabilityResponse_class_data_;
class CheckAvailabilityResponse_ItemsEntry_DoNotUse;
struct CheckAvailabilityResponse_ItemsEntry_DoNotUseDefaultTypeInternal;
extern CheckAvailabilityResponse_ItemsEntry_DoNotUseDefaultTypeInternal _CheckAvailabilityResponse_ItemsEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CheckAvailabilityResponse_ItemsEntry_DoNotUse_class_data_;
class ProcessCustomerOrderRequest;
struct ProcessCustomerOrderRequestDefaultTypeInternal;
extern ProcessCustomerOrderRequestDefaultTypeInternal _ProcessCustomerOrderRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ProcessCustomerOrderRequest_class_data_;
class ProcessCustomerOrderRequest_ItemsEntry_DoNotUse;
struct ProcessCustomerOrderRequest_ItemsEntry_DoNotUseDefaultTypeInternal;
extern ProcessCustomerOrderRequest_ItemsEntry_DoNotUseDefaultTypeInternal _ProcessCustomerOrderRequest_ItemsEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ProcessCustomerOrderRequest_ItemsEntry_DoNotUse_class_data_;
class ProcessCustomerOrderResponse;
struct ProcessCustomerOrderResponseDefaultTypeInternal;
extern ProcessCustomerOrderResponseDefaultTypeInternal _ProcessCustomerOrderResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ProcessCustomerOrderResponse_class_data_;
class ReleaseItemsRequest;
struct ReleaseItemsRequestDefaultTypeInternal;
extern ReleaseItemsRequestDefaultTypeInternal _ReleaseItemsRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReleaseItemsRequest_class_data_;
class ReleaseItemsRequest_ItemsEntry_DoNotUse;
struct ReleaseItemsRequest_ItemsEntry_DoNotUseDefaultTypeInternal;
extern ReleaseItemsRequest_ItemsEntry_DoNotUseDefaultTypeInternal _ReleaseItemsRequest_ItemsEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReleaseItemsRequest_ItemsEntry_DoNotUse_class_data_;
class ReleaseItemsResponse;
struct ReleaseItemsResponseDefaultTypeInternal;
extern ReleaseItemsResponseDefaultTypeInternal _ReleaseItemsResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReleaseItemsResponse_class_data_;
class ReportJobStatusRequest;
struct ReportJobStatusRequestDefaultTypeInternal;
extern ReportJobStatusRequestDefaultTypeInternal _ReportJobStatusRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReportJobStatusRequest_class_data_;
class ReportJobStatusRequest_ProcessedItemsEntry_DoNotUse;
struct ReportJobStatusRequest_ProcessedItemsEntry_DoNotUseDefaultTypeInternal;
extern ReportJobStatusRequest_ProcessedItemsEntry_DoNotUseDefaultTypeInternal _ReportJobStatusRequest_ProcessedItemsEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReportJobStatusRequest_ProcessedItemsEntry_DoNotUse_class_data_;
class ReportJobStatusResponse;
struct ReportJobStatusResponseDefaultTypeInternal;
extern ReportJobStatusResponseDefaultTypeInternal _ReportJobStatusResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReportJobStatusResponse_class_data_;
class ReserveItemsRequest;
struct ReserveItemsRequestDefaultTypeInternal;
extern ReserveItemsRequestDefaultTypeInternal _ReserveItemsRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReserveItemsRequest_class_data_;
class ReserveItemsRequest_ItemsEntry_DoNotUse;
struct ReserveItemsRequest_ItemsEntry_DoNotUseDefaultTypeInternal;
extern ReserveItemsRequest_ItemsEntry_DoNotUseDefaultTypeInternal _ReserveItemsRequest_ItemsEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReserveItemsRequest_ItemsEntry_DoNotUse_class_data_;
class ReserveItemsResponse;
struct ReserveItemsResponseDefaultTypeInternal;
extern ReserveItemsResponseDefaultTypeInternal _ReserveItemsResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReserveItemsResponse_class_data_;
class RestockItem;
struct RestockItemDefaultTypeInternal;
extern RestockItemDefaultTypeInternal _RestockItem_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RestockItem_class_data_;
class RestockItemsOrderRequest;
struct RestockItemsOrderRequestDefaultTypeInternal;
extern RestockItemsOrderRequestDefaultTypeInternal _RestockItemsOrderRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RestockItemsOrderRequest_class_data_;
class RestockItemsOrderResponse;
struct RestockItemsOrderResponseDefaultTypeInternal;
extern RestockItemsOrderResponseDefaultTypeInternal _RestockItemsOrderResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RestockItemsOrderResponse_class_data_;
class StockLevel;
struct StockLevelDefaultTypeInternal;
extern StockLevelDefaultTypeInternal _StockLevel_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull StockLevel_class_data_;
}  // namespace inventory
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace inventory {

// ===================================================================


// -------------------------------------------------------------------

class StockLevel final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:inventory.StockLevel) */ {
 public:
  inline StockLevel() : StockLevel(nullptr) {}
  ~StockLevel() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StockLevel* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StockLevel));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StockLevel(::google::protobuf::internal::ConstantInitialized);

  inline StockLevel(const StockLevel& from) : StockLevel(nullptr, from) {}
  inline StockLevel(StockLevel&& from) noexcept
      : StockLevel(nullptr, ::std::move(from)) {}
  inline StockLevel& operator=(const StockLevel& from) {
    CopyFrom(from);
    return *this;
  }
  inline StockLevel& operator=(StockLevel&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StockLevel& default_instance() {
    return *reinterpret_cast<const StockLevel*>(
        &_StockLevel_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(StockLevel& a, StockLevel& b) { a.Swap(&b); }
  inline void Swap(StockLevel* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StockLevel* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StockLevel* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<StockLevel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StockLevel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StockLevel& from) { StockLevel::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(StockLevel* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "inventory.StockLevel"; }

  explicit StockLevel(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  StockLevel(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const StockLevel& from);
  StockLevel(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, StockLevel&& from) noexcept
      : StockLevel(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSkuFieldNumber = 1,
    kNameFieldNumber = 2,
    kAisleTypeFieldNumber = 3,
    kQuantityAvailableFieldNumber = 4,
  };
  // string sku = 1;
  void clear_sku() ;
  const ::std::string& sku() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_sku(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_sku();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_sku();
  void set_allocated_sku(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_sku() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_sku(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_sku();

  public:
  // string name = 2;
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // string aisle_type = 3;
  void clear_aisle_type() ;
  const ::std::string& aisle_type() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_aisle_type(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_aisle_type();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_aisle_type();
  void set_allocated_aisle_type(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_aisle_type() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_aisle_type(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_aisle_type();

  public:
  // int32 quantity_available = 4;
  void clear_quantity_available() ;
  ::int32_t quantity_available() const;
  void set_quantity_available(::int32_t value);

  private:
  ::int32_t _internal_quantity_available() const;
  void _internal_set_quantity_available(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:inventory.StockLevel)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 46,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const StockLevel& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr sku_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr aisle_type_;
    ::int32_t quantity_available_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2finventory_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull StockLevel_class_data_;
// -------------------------------------------------------------------

class RestockItemsOrderResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:inventory.RestockItemsOrderResponse) */ {
 public:
  inline RestockItemsOrderResponse() : RestockItemsOrderResponse(nullptr) {}
  ~RestockItemsOrderResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RestockItemsOrderResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RestockItemsOrderResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RestockItemsOrderResponse(::google::protobuf::internal::ConstantInitialized);

  inline RestockItemsOrderResponse(const RestockItemsOrderResponse& from) : RestockItemsOrderResponse(nullptr, from) {}
  inline RestockItemsOrderResponse(RestockItemsOrderResponse&& from) noexcept
      : RestockItemsOrderResponse(nullptr, ::std::move(from)) {}
  inline RestockItemsOrderResponse& operator=(const RestockItemsOrderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RestockItemsOrderResponse& operator=(RestockItemsOrderResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RestockItemsOrderResponse& default_instance() {
    return *reinterpret_cast<const RestockItemsOrderResponse*>(
        &_RestockItemsOrderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(RestockItemsOrderResponse& a, RestockItemsOrderResponse& b) { a.Swap(&b); }
  inline void Swap(RestockItemsOrderResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RestockItemsOrderResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RestockItemsOrderResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RestockItemsOrderResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RestockItemsOrderResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RestockItemsOrderResponse& from) { RestockItemsOrderResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RestockItemsOrderResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "inventory.RestockItemsOrderResponse"; }

  explicit RestockItemsOrderResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RestockItemsOrderResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RestockItemsOrderResponse& from);
  RestockItemsOrderResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RestockItemsOrderResponse&& from) noexcept
      : RestockItemsOrderResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:inventory.RestockItemsOrderResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RestockItemsOrderResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    bool success_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2finventory_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RestockItemsOrderResponse_class_data_;
// -------------------------------------------------------------------

class ReserveItemsResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:inventory.ReserveItemsResponse) */ {
 public:
  inline ReserveItemsResponse() : ReserveItemsResponse(nullptr) {}
  ~ReserveItemsResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReserveItemsResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReserveItemsResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReserveItemsResponse(::google::protobuf::internal::ConstantInitialized);

  inline ReserveItemsResponse(const ReserveItemsResponse& from) : ReserveItemsResponse(nullptr, from) {}
  inline ReserveItemsResponse(ReserveItemsResponse&& from) noexcept
      : ReserveItemsResponse(nullptr, ::std::move(from)) {}
  inline ReserveItemsResponse& operator=(const ReserveItemsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReserveItemsResponse& operator=(ReserveItemsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReserveItemsResponse& default_instance() {
    return *reinterpret_cast<const ReserveItemsResponse*>(
        &_ReserveItemsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(ReserveItemsResponse& a, ReserveItemsResponse& b) { a.Swap(&b); }
  inline void Swap(ReserveItemsResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReserveItemsResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReserveItemsResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReserveItemsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReserveItemsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReserveItemsResponse& from) { ReserveItemsResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReserveItemsResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "inventory.ReserveItemsResponse"; }

  explicit ReserveItemsResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ReserveItemsResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ReserveItemsResponse& from);
  ReserveItemsResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ReserveItemsResponse&& from) noexcept
      : ReserveItemsResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOrderIdFieldNumber = 1,
    kErrorMessageFieldNumber = 3,
    kSuccessFieldNumber = 2,
  };
  // string order_id = 1;
  void clear_order_id() ;
  const ::std::string& order_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_order_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_order_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_order_id();
  void set_allocated_order_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_order_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_order_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_order_id();

  public:
  // string error_message = 3;
  void clear_error_message() ;
  const ::std::string& error_message() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_error_message(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_error_message();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_error_message();
  void set_allocated_error_message(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_error_message() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_error_message();

  public:
  // bool success = 2;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:inventory.ReserveItemsResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 60,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ReserveItemsResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr order_id_;
    ::google::protobuf::internal::ArenaStringPtr error_message_;
    bool success_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2finventory_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ReserveItemsResponse_class_data_;
// -------------------------------------------------------------------

class ReserveItemsRequest_ItemsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::int32_t,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_INT32> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>;
  ReserveItemsRequest_ItemsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReserveItemsRequest_ItemsEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit ReserveItemsRequest_ItemsEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_ReserveItemsRequest_ItemsEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_proto_2finventory_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 52,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull ReserveItemsRequest_ItemsEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class ReportJobStatusResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:inventory.ReportJobStatusResponse) */ {
 public:
  inline ReportJobStatusResponse() : ReportJobStatusResponse(nullptr) {}
  ~ReportJobStatusResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReportJobStatusResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReportJobStatusResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReportJobStatusResponse(::google::protobuf::internal::ConstantInitialized);

  inline ReportJobStatusResponse(const ReportJobStatusResponse& from) : ReportJobStatusResponse(nullptr, from) {}
  inline ReportJobStatusResponse(ReportJobStatusResponse&& from) noexcept
      : ReportJobStatusResponse(nullptr, ::std::move(from)) {}
  inline ReportJobStatusResponse& operator=(const ReportJobStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportJobStatusResponse& operator=(ReportJobStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReportJobStatusResponse& default_instance() {
    return *reinterpret_cast<const ReportJobStatusResponse*>(
        &_ReportJobStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(ReportJobStatusResponse& a, ReportJobStatusResponse& b) { a.Swap(&b); }
  inline void Swap(ReportJobStatusResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportJobStatusResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReportJobStatusResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReportJobStatusResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReportJobStatusResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReportJobStatusResponse& from) { ReportJobStatusResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReportJobStatusResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "inventory.ReportJobStatusResponse"; }

  explicit ReportJobStatusResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ReportJobStatusResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ReportJobStatusResponse& from);
  ReportJobStatusResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ReportJobStatusResponse&& from) noexcept
      : ReportJobStatusResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:inventory.ReportJobStatusResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ReportJobStatusResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    bool success_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2finventory_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ReportJobStatusResponse_class_data_;
// -------------------------------------------------------------------

class ReportJobStatusRequest_ProcessedItemsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::int32_t,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_INT32> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>;
  ReportJobStatusRequest_ProcessedItemsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReportJobStatusRequest_ProcessedItemsEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit ReportJobStatusRequest_ProcessedItemsEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_ReportJobStatusRequest_ProcessedItemsEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_proto_2finventory_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 64,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull ReportJobStatusRequest_ProcessedItemsEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class ReleaseItemsResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:inventory.ReleaseItemsResponse) */ {
 public:
  inline ReleaseItemsResponse() : ReleaseItemsResponse(nullptr) {}
  ~ReleaseItemsResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReleaseItemsResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReleaseItemsResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReleaseItemsResponse(::google::protobuf::internal::ConstantInitialized);

  inline ReleaseItemsResponse(const ReleaseItemsResponse& from) : ReleaseItemsResponse(nullptr, from) {}
  inline ReleaseItemsResponse(ReleaseItemsResponse&& from) noexcept
      : ReleaseItemsResponse(nullptr, ::std::move(from)) {}
  inline ReleaseItemsResponse& operator=(const ReleaseItemsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReleaseItemsResponse& operator=(ReleaseItemsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReleaseItemsResponse& default_instance() {
    return *reinterpret_cast<const ReleaseItemsResponse*>(
        &_ReleaseItemsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(ReleaseItemsResponse& a, ReleaseItemsResponse& b) { a.Swap(&b); }
  inline void Swap(ReleaseItemsResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReleaseItemsResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReleaseItemsResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReleaseItemsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReleaseItemsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReleaseItemsResponse& from) { ReleaseItemsResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReleaseItemsResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "inventory.ReleaseItemsResponse"; }

  explicit ReleaseItemsResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ReleaseItemsResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ReleaseItemsResponse& from);
  ReleaseItemsResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ReleaseItemsResponse&& from) noexcept
      : ReleaseItemsResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:inventory.ReleaseItemsResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ReleaseItemsResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    bool success_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2finventory_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ReleaseItemsResponse_class_data_;
// -------------------------------------------------------------------

class ReleaseItemsRequest_ItemsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::int32_t,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_INT32> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>;
  ReleaseItemsRequest_ItemsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReleaseItemsRequest_ItemsEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit ReleaseItemsRequest_ItemsEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_ReleaseItemsRequest_ItemsEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_proto_2finventory_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 52,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull ReleaseItemsRequest_ItemsEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class ProcessCustomerOrderResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:inventory.ProcessCustomerOrderResponse) */ {
 public:
  inline ProcessCustomerOrderResponse() : ProcessCustomerOrderResponse(nullptr) {}
  ~ProcessCustomerOrderResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ProcessCustomerOrderResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ProcessCustomerOrderResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ProcessCustomerOrderResponse(::google::protobuf::internal::ConstantInitialized);

  inline ProcessCustomerOrderResponse(const ProcessCustomerOrderResponse& from) : ProcessCustomerOrderResponse(nullptr, from) {}
  inline ProcessCustomerOrderResponse(ProcessCustomerOrderResponse&& from) noexcept
      : ProcessCustomerOrderResponse(nullptr, ::std::move(from)) {}
  inline ProcessCustomerOrderResponse& operator=(const ProcessCustomerOrderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessCustomerOrderResponse& operator=(ProcessCustomerOrderResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessCustomerOrderResponse& default_instance() {
    return *reinterpret_cast<const ProcessCustomerOrderResponse*>(
        &_ProcessCustomerOrderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(ProcessCustomerOrderResponse& a, ProcessCustomerOrderResponse& b) { a.Swap(&b); }
  inline void Swap(ProcessCustomerOrderResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessCustomerOrderResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessCustomerOrderResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ProcessCustomerOrderResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ProcessCustomerOrderResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ProcessCustomerOrderResponse& from) { ProcessCustomerOrderResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ProcessCustomerOrderResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "inventory.ProcessCustomerOrderResponse"; }

  explicit ProcessCustomerOrderResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ProcessCustomerOrderResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ProcessCustomerOrderResponse& from);
  ProcessCustomerOrderResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ProcessCustomerOrderResponse&& from) noexcept
      : ProcessCustomerOrderResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string message = 2;
  void clear_message() ;
  const ::std::string& message() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_message();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_message();
  void set_allocated_message(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_message() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_message(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_message();

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:inventory.ProcessCustomerOrderResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 54,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ProcessCustomerOrderResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    bool success_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2finventory_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ProcessCustomerOrderResponse_class_data_;
// -------------------------------------------------------------------

class ProcessCustomerOrderRequest_ItemsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::int32_t,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_INT32> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>;
  ProcessCustomerOrderRequest_ItemsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ProcessCustomerOrderRequest_ItemsEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit ProcessCustomerOrderRequest_ItemsEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_ProcessCustomerOrderRequest_ItemsEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_proto_2finventory_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 60,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull ProcessCustomerOrderRequest_ItemsEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class CheckAvailabilityRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:inventory.CheckAvailabilityRequest) */ {
 public:
  inline CheckAvailabilityRequest() : CheckAvailabilityRequest(nullptr) {}
  ~CheckAvailabilityRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CheckAvailabilityRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CheckAvailabilityRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CheckAvailabilityRequest(::google::protobuf::internal::ConstantInitialized);

  inline CheckAvailabilityRequest(const CheckAvailabilityRequest& from) : CheckAvailabilityRequest(nullptr, from) {}
  inline CheckAvailabilityRequest(CheckAvailabilityRequest&& from) noexcept
      : CheckAvailabilityRequest(nullptr, ::std::move(from)) {}
  inline CheckAvailabilityRequest& operator=(const CheckAvailabilityRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckAvailabilityRequest& operator=(CheckAvailabilityRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckAvailabilityRequest& default_instance() {
    return *reinterpret_cast<const CheckAvailabilityRequest*>(
        &_CheckAvailabilityRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(CheckAvailabilityRequest& a, CheckAvailabilityRequest& b) { a.Swap(&b); }
  inline void Swap(CheckAvailabilityRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckAvailabilityRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckAvailabilityRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CheckAvailabilityRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CheckAvailabilityRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CheckAvailabilityRequest& from) { CheckAvailabilityRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CheckAvailabilityRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "inventory.CheckAvailabilityRequest"; }

  explicit CheckAvailabilityRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CheckAvailabilityRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CheckAvailabilityRequest& from);
  CheckAvailabilityRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CheckAvailabilityRequest&& from) noexcept
      : CheckAvailabilityRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSkusFieldNumber = 1,
  };
  // repeated string skus = 1;
  int skus_size() const;
  private:
  int _internal_skus_size() const;

  public:
  void clear_skus() ;
  const ::std::string& skus(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_skus(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_skus(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_skus();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_skus(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& skus() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_skus();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_skus() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_skus();

  public:
  // @@protoc_insertion_point(class_scope:inventory.CheckAvailabilityRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 47,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CheckAvailabilityRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> skus_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2finventory_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CheckAvailabilityRequest_class_data_;
// -------------------------------------------------------------------

class RestockItem final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:inventory.RestockItem) */ {
 public:
  inline RestockItem() : RestockItem(nullptr) {}
  ~RestockItem() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RestockItem* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RestockItem));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RestockItem(::google::protobuf::internal::ConstantInitialized);

  inline RestockItem(const RestockItem& from) : RestockItem(nullptr, from) {}
  inline RestockItem(RestockItem&& from) noexcept
      : RestockItem(nullptr, ::std::move(from)) {}
  inline RestockItem& operator=(const RestockItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline RestockItem& operator=(RestockItem&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RestockItem& default_instance() {
    return *reinterpret_cast<const RestockItem*>(
        &_RestockItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(RestockItem& a, RestockItem& b) { a.Swap(&b); }
  inline void Swap(RestockItem* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RestockItem* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RestockItem* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RestockItem>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RestockItem& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RestockItem& from) { RestockItem::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RestockItem* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "inventory.RestockItem"; }

  explicit RestockItem(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RestockItem(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RestockItem& from);
  RestockItem(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RestockItem&& from) noexcept
      : RestockItem(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSkuFieldNumber = 1,
    kNameFieldNumber = 2,
    kAisleTypeFieldNumber = 3,
    kMfdDateFieldNumber = 6,
    kExpiryDateFieldNumber = 7,
    kUnitCostFieldNumber = 5,
    kQuantityFieldNumber = 4,
  };
  // string sku = 1;
  void clear_sku() ;
  const ::std::string& sku() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_sku(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_sku();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_sku();
  void set_allocated_sku(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_sku() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_sku(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_sku();

  public:
  // string name = 2;
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // string aisle_type = 3;
  void clear_aisle_type() ;
  const ::std::string& aisle_type() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_aisle_type(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_aisle_type();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_aisle_type();
  void set_allocated_aisle_type(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_aisle_type() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_aisle_type(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_aisle_type();

  public:
  // .google.protobuf.Timestamp mfd_date = 6;
  bool has_mfd_date() const;
  void clear_mfd_date() ;
  const ::google::protobuf::Timestamp& mfd_date() const;
  [[nodiscard]] ::google::protobuf::Timestamp* PROTOBUF_NULLABLE release_mfd_date();
  ::google::protobuf::Timestamp* PROTOBUF_NONNULL mutable_mfd_date();
  void set_allocated_mfd_date(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_mfd_date(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value);
  ::google::protobuf::Timestamp* PROTOBUF_NULLABLE unsafe_arena_release_mfd_date();

  private:
  const ::google::protobuf::Timestamp& _internal_mfd_date() const;
  ::google::protobuf::Timestamp* PROTOBUF_NONNULL _internal_mutable_mfd_date();

  public:
  // .google.protobuf.Timestamp expiry_date = 7;
  bool has_expiry_date() const;
  void clear_expiry_date() ;
  const ::google::protobuf::Timestamp& expiry_date() const;
  [[nodiscard]] ::google::protobuf::Timestamp* PROTOBUF_NULLABLE release_expiry_date();
  ::google::protobuf::Timestamp* PROTOBUF_NONNULL mutable_expiry_date();
  void set_allocated_expiry_date(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_expiry_date(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value);
  ::google::protobuf::Timestamp* PROTOBUF_NULLABLE unsafe_arena_release_expiry_date();

  private:
  const ::google::protobuf::Timestamp& _internal_expiry_date() const;
  ::google::protobuf::Timestamp* PROTOBUF_NONNULL _internal_mutable_expiry_date();

  public:
  // double unit_cost = 5;
  void clear_unit_cost() ;
  double unit_cost() const;
  void set_unit_cost(double value);

  private:
  double _internal_unit_cost() const;
  void _internal_set_unit_cost(double value);

  public:
  // int32 quantity = 4;
  void clear_quantity() ;
  ::int32_t quantity() const;
  void set_quantity(::int32_t value);

  private:
  ::int32_t _internal_quantity() const;
  void _internal_set_quantity(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:inventory.RestockItem)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   2, 47,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RestockItem& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr sku_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr aisle_type_;
    ::google::protobuf::Timestamp* PROTOBUF_NULLABLE mfd_date_;
    ::google::protobuf::Timestamp* PROTOBUF_NULLABLE expiry_date_;
    double unit_cost_;
    ::int32_t quantity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2finventory_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RestockItem_class_data_;
// -------------------------------------------------------------------

class ReserveItemsRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:inventory.ReserveItemsRequest) */ {
 public:
  inline ReserveItemsRequest() : ReserveItemsRequest(nullptr) {}
  ~ReserveItemsRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReserveItemsRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReserveItemsRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReserveItemsRequest(::google::protobuf::internal::ConstantInitialized);

  inline ReserveItemsRequest(const ReserveItemsRequest& from) : ReserveItemsRequest(nullptr, from) {}
  inline ReserveItemsRequest(ReserveItemsRequest&& from) noexcept
      : ReserveItemsRequest(nullptr, ::std::move(from)) {}
  inline ReserveItemsRequest& operator=(const ReserveItemsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReserveItemsRequest& operator=(ReserveItemsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReserveItemsRequest& default_instance() {
    return *reinterpret_cast<const ReserveItemsRequest*>(
        &_ReserveItemsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(ReserveItemsRequest& a, ReserveItemsRequest& b) { a.Swap(&b); }
  inline void Swap(ReserveItemsRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReserveItemsRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReserveItemsRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReserveItemsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReserveItemsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReserveItemsRequest& from) { ReserveItemsRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReserveItemsRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "inventory.ReserveItemsRequest"; }

  explicit ReserveItemsRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ReserveItemsRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ReserveItemsRequest& from);
  ReserveItemsRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ReserveItemsRequest&& from) noexcept
      : ReserveItemsRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOrderIdFieldNumber = 1,
    kItemsFieldNumber = 2,
  };
  // string order_id = 1;
  void clear_order_id() ;
  const ::std::string& order_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_order_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_order_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_order_id();
  void set_allocated_order_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_order_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_order_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_order_id();

  public:
  // map<string, int32> items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  const ::google::protobuf::Map<::std::string, ::int32_t>& items() const;
  ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL mutable_items();

  private:
  const ::google::protobuf::Map<::std::string, ::int32_t>& _internal_items() const;
  ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL _internal_mutable_items();

  public:
  // @@protoc_insertion_point(class_scope:inventory.ReserveItemsRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 2,
                                   1, 51,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ReserveItemsRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr order_id_;
    ::google::protobuf::internal::MapField<ReserveItemsRequest_ItemsEntry_DoNotUse, ::std::string, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>
        items_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2finventory_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ReserveItemsRequest_class_data_;
// -------------------------------------------------------------------

class ReportJobStatusRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:inventory.ReportJobStatusRequest) */ {
 public:
  inline ReportJobStatusRequest() : ReportJobStatusRequest(nullptr) {}
  ~ReportJobStatusRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReportJobStatusRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReportJobStatusRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReportJobStatusRequest(::google::protobuf::internal::ConstantInitialized);

  inline ReportJobStatusRequest(const ReportJobStatusRequest& from) : ReportJobStatusRequest(nullptr, from) {}
  inline ReportJobStatusRequest(ReportJobStatusRequest&& from) noexcept
      : ReportJobStatusRequest(nullptr, ::std::move(from)) {}
  inline ReportJobStatusRequest& operator=(const ReportJobStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportJobStatusRequest& operator=(ReportJobStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReportJobStatusRequest& default_instance() {
    return *reinterpret_cast<const ReportJobStatusRequest*>(
        &_ReportJobStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(ReportJobStatusRequest& a, ReportJobStatusRequest& b) { a.Swap(&b); }
  inline void Swap(ReportJobStatusRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportJobStatusRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReportJobStatusRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReportJobStatusRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReportJobStatusRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReportJobStatusRequest& from) { ReportJobStatusRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReportJobStatusRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "inventory.ReportJobStatusRequest"; }

  explicit ReportJobStatusRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ReportJobStatusRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ReportJobStatusRequest& from);
  ReportJobStatusRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ReportJobStatusRequest&& from) noexcept
      : ReportJobStatusRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOrderIdFieldNumber = 1,
    kStatusFieldNumber = 3,
    kOrderTypeFieldNumber = 5,
    kProcessedItemsFieldNumber = 4,
  };
  // string order_id = 1;
  void clear_order_id() ;
  const ::std::string& order_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_order_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_order_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_order_id();
  void set_allocated_order_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_order_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_order_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_order_id();

  public:
  // string status = 3;
  void clear_status() ;
  const ::std::string& status() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_status(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_status();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_status();
  void set_allocated_status(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_status() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_status(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_status();

  public:
  // string order_type = 5;
  void clear_order_type() ;
  const ::std::string& order_type() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_order_type(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_order_type();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_order_type();
  void set_allocated_order_type(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_order_type() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_order_type(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_order_type();

  public:
  // map<string, int32> processed_items = 4;
  int processed_items_size() const;
  private:
  int _internal_processed_items_size() const;

  public:
  void clear_processed_items() ;
  const ::google::protobuf::Map<::std::string, ::int32_t>& processed_items() const;
  ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL mutable_processed_items();

  private:
  const ::google::protobuf::Map<::std::string, ::int32_t>& _internal_processed_items() const;
  ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL _internal_mutable_processed_items();

  public:
  // @@protoc_insertion_point(class_scope:inventory.ReportJobStatusRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 4,
                                   1, 80,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ReportJobStatusRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr order_id_;
    ::google::protobuf::internal::ArenaStringPtr status_;
    ::google::protobuf::internal::ArenaStringPtr order_type_;
    ::google::protobuf::internal::MapField<ReportJobStatusRequest_ProcessedItemsEntry_DoNotUse, ::std::string, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>
        processed_items_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2finventory_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ReportJobStatusRequest_class_data_;
// -------------------------------------------------------------------

class ReleaseItemsRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:inventory.ReleaseItemsRequest) */ {
 public:
  inline ReleaseItemsRequest() : ReleaseItemsRequest(nullptr) {}
  ~ReleaseItemsRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReleaseItemsRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReleaseItemsRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReleaseItemsRequest(::google::protobuf::internal::ConstantInitialized);

  inline ReleaseItemsRequest(const ReleaseItemsRequest& from) : ReleaseItemsRequest(nullptr, from) {}
  inline ReleaseItemsRequest(ReleaseItemsRequest&& from) noexcept
      : ReleaseItemsRequest(nullptr, ::std::move(from)) {}
  inline ReleaseItemsRequest& operator=(const ReleaseItemsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReleaseItemsRequest& operator=(ReleaseItemsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReleaseItemsRequest& default_instance() {
    return *reinterpret_cast<const ReleaseItemsRequest*>(
        &_ReleaseItemsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(ReleaseItemsRequest& a, ReleaseItemsRequest& b) { a.Swap(&b); }
  inline void Swap(ReleaseItemsRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReleaseItemsRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReleaseItemsRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReleaseItemsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReleaseItemsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReleaseItemsRequest& from) { ReleaseItemsRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReleaseItemsRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "inventory.ReleaseItemsRequest"; }

  explicit ReleaseItemsRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ReleaseItemsRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ReleaseItemsRequest& from);
  ReleaseItemsRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ReleaseItemsRequest&& from) noexcept
      : ReleaseItemsRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOrderIdFieldNumber = 1,
    kItemsFieldNumber = 2,
  };
  // string order_id = 1;
  void clear_order_id() ;
  const ::std::string& order_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_order_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_order_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_order_id();
  void set_allocated_order_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_order_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_order_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_order_id();

  public:
  // map<string, int32> items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  const ::google::protobuf::Map<::std::string, ::int32_t>& items() const;
  ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL mutable_items();

  private:
  const ::google::protobuf::Map<::std::string, ::int32_t>& _internal_items() const;
  ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL _internal_mutable_items();

  public:
  // @@protoc_insertion_point(class_scope:inventory.ReleaseItemsRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 2,
                                   1, 51,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ReleaseItemsRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr order_id_;
    ::google::protobuf::internal::MapField<ReleaseItemsRequest_ItemsEntry_DoNotUse, ::std::string, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>
        items_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2finventory_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ReleaseItemsRequest_class_data_;
// -------------------------------------------------------------------

class ProcessCustomerOrderRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:inventory.ProcessCustomerOrderRequest) */ {
 public:
  inline ProcessCustomerOrderRequest() : ProcessCustomerOrderRequest(nullptr) {}
  ~ProcessCustomerOrderRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ProcessCustomerOrderRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ProcessCustomerOrderRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ProcessCustomerOrderRequest(::google::protobuf::internal::ConstantInitialized);

  inline ProcessCustomerOrderRequest(const ProcessCustomerOrderRequest& from) : ProcessCustomerOrderRequest(nullptr, from) {}
  inline ProcessCustomerOrderRequest(ProcessCustomerOrderRequest&& from) noexcept
      : ProcessCustomerOrderRequest(nullptr, ::std::move(from)) {}
  inline ProcessCustomerOrderRequest& operator=(const ProcessCustomerOrderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessCustomerOrderRequest& operator=(ProcessCustomerOrderRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessCustomerOrderRequest& default_instance() {
    return *reinterpret_cast<const ProcessCustomerOrderRequest*>(
        &_ProcessCustomerOrderRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(ProcessCustomerOrderRequest& a, ProcessCustomerOrderRequest& b) { a.Swap(&b); }
  inline void Swap(ProcessCustomerOrderRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessCustomerOrderRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessCustomerOrderRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ProcessCustomerOrderRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ProcessCustomerOrderRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ProcessCustomerOrderRequest& from) { ProcessCustomerOrderRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ProcessCustomerOrderRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "inventory.ProcessCustomerOrderRequest"; }

  explicit ProcessCustomerOrderRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ProcessCustomerOrderRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ProcessCustomerOrderRequest& from);
  ProcessCustomerOrderRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ProcessCustomerOrderRequest&& from) noexcept
      : ProcessCustomerOrderRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOrderIdFieldNumber = 1,
    kItemsFieldNumber = 2,
  };
  // string order_id = 1;
  void clear_order_id() ;
  const ::std::string& order_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_order_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_order_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_order_id();
  void set_allocated_order_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_order_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_order_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_order_id();

  public:
  // map<string, int32> items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  const ::google::protobuf::Map<::std::string, ::int32_t>& items() const;
  ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL mutable_items();

  private:
  const ::google::protobuf::Map<::std::string, ::int32_t>& _internal_items() const;
  ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL _internal_mutable_items();

  public:
  // @@protoc_insertion_point(class_scope:inventory.ProcessCustomerOrderRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 2,
                                   1, 59,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ProcessCustomerOrderRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr order_id_;
    ::google::protobuf::internal::MapField<ProcessCustomerOrderRequest_ItemsEntry_DoNotUse, ::std::string, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>
        items_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2finventory_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ProcessCustomerOrderRequest_class_data_;
// -------------------------------------------------------------------

class CheckAvailabilityResponse_ItemsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  CheckAvailabilityResponse_ItemsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CheckAvailabilityResponse_ItemsEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit CheckAvailabilityResponse_ItemsEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_CheckAvailabilityResponse_ItemsEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_proto_2finventory_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 58,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull CheckAvailabilityResponse_ItemsEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class RestockItemsOrderRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:inventory.RestockItemsOrderRequest) */ {
 public:
  inline RestockItemsOrderRequest() : RestockItemsOrderRequest(nullptr) {}
  ~RestockItemsOrderRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RestockItemsOrderRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RestockItemsOrderRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RestockItemsOrderRequest(::google::protobuf::internal::ConstantInitialized);

  inline RestockItemsOrderRequest(const RestockItemsOrderRequest& from) : RestockItemsOrderRequest(nullptr, from) {}
  inline RestockItemsOrderRequest(RestockItemsOrderRequest&& from) noexcept
      : RestockItemsOrderRequest(nullptr, ::std::move(from)) {}
  inline RestockItemsOrderRequest& operator=(const RestockItemsOrderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RestockItemsOrderRequest& operator=(RestockItemsOrderRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RestockItemsOrderRequest& default_instance() {
    return *reinterpret_cast<const RestockItemsOrderRequest*>(
        &_RestockItemsOrderRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(RestockItemsOrderRequest& a, RestockItemsOrderRequest& b) { a.Swap(&b); }
  inline void Swap(RestockItemsOrderRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RestockItemsOrderRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RestockItemsOrderRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RestockItemsOrderRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RestockItemsOrderRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RestockItemsOrderRequest& from) { RestockItemsOrderRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RestockItemsOrderRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "inventory.RestockItemsOrderRequest"; }

  explicit RestockItemsOrderRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RestockItemsOrderRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RestockItemsOrderRequest& from);
  RestockItemsOrderRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RestockItemsOrderRequest&& from) noexcept
      : RestockItemsOrderRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kItemsFieldNumber = 2,
    kOrderIdFieldNumber = 1,
  };
  // repeated .inventory.RestockItem items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::inventory::RestockItem* PROTOBUF_NONNULL mutable_items(int index);
  ::google::protobuf::RepeatedPtrField<::inventory::RestockItem>* PROTOBUF_NONNULL mutable_items();

  private:
  const ::google::protobuf::RepeatedPtrField<::inventory::RestockItem>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<::inventory::RestockItem>* PROTOBUF_NONNULL _internal_mutable_items();
  public:
  const ::inventory::RestockItem& items(int index) const;
  ::inventory::RestockItem* PROTOBUF_NONNULL add_items();
  const ::google::protobuf::RepeatedPtrField<::inventory::RestockItem>& items() const;
  // string order_id = 1;
  void clear_order_id() ;
  const ::std::string& order_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_order_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_order_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_order_id();
  void set_allocated_order_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_order_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_order_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_order_id();

  public:
  // @@protoc_insertion_point(class_scope:inventory.RestockItemsOrderRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 51,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RestockItemsOrderRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::inventory::RestockItem > items_;
    ::google::protobuf::internal::ArenaStringPtr order_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2finventory_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RestockItemsOrderRequest_class_data_;
// -------------------------------------------------------------------

class CheckAvailabilityResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:inventory.CheckAvailabilityResponse) */ {
 public:
  inline CheckAvailabilityResponse() : CheckAvailabilityResponse(nullptr) {}
  ~CheckAvailabilityResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CheckAvailabilityResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CheckAvailabilityResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CheckAvailabilityResponse(::google::protobuf::internal::ConstantInitialized);

  inline CheckAvailabilityResponse(const CheckAvailabilityResponse& from) : CheckAvailabilityResponse(nullptr, from) {}
  inline CheckAvailabilityResponse(CheckAvailabilityResponse&& from) noexcept
      : CheckAvailabilityResponse(nullptr, ::std::move(from)) {}
  inline CheckAvailabilityResponse& operator=(const CheckAvailabilityResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckAvailabilityResponse& operator=(CheckAvailabilityResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckAvailabilityResponse& default_instance() {
    return *reinterpret_cast<const CheckAvailabilityResponse*>(
        &_CheckAvailabilityResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(CheckAvailabilityResponse& a, CheckAvailabilityResponse& b) { a.Swap(&b); }
  inline void Swap(CheckAvailabilityResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckAvailabilityResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckAvailabilityResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CheckAvailabilityResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CheckAvailabilityResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CheckAvailabilityResponse& from) { CheckAvailabilityResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CheckAvailabilityResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "inventory.CheckAvailabilityResponse"; }

  explicit CheckAvailabilityResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CheckAvailabilityResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CheckAvailabilityResponse& from);
  CheckAvailabilityResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CheckAvailabilityResponse&& from) noexcept
      : CheckAvailabilityResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kItemsFieldNumber = 1,
  };
  // map<string, .inventory.StockLevel> items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  const ::google::protobuf::Map<::std::string, ::inventory::StockLevel>& items() const;
  ::google::protobuf::Map<::std::string, ::inventory::StockLevel>* PROTOBUF_NONNULL mutable_items();

  private:
  const ::google::protobuf::Map<::std::string, ::inventory::StockLevel>& _internal_items() const;
  ::google::protobuf::Map<::std::string, ::inventory::StockLevel>* PROTOBUF_NONNULL _internal_mutable_items();

  public:
  // @@protoc_insertion_point(class_scope:inventory.CheckAvailabilityResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   2, 49,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CheckAvailabilityResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<CheckAvailabilityResponse_ItemsEntry_DoNotUse, ::std::string, ::inventory::StockLevel,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        items_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2finventory_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CheckAvailabilityResponse_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// CheckAvailabilityRequest

// repeated string skus = 1;
inline int CheckAvailabilityRequest::_internal_skus_size() const {
  return _internal_skus().size();
}
inline int CheckAvailabilityRequest::skus_size() const {
  return _internal_skus_size();
}
inline void CheckAvailabilityRequest::clear_skus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.skus_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::std::string* PROTOBUF_NONNULL CheckAvailabilityRequest::add_skus()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s =
      _internal_mutable_skus()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add_mutable:inventory.CheckAvailabilityRequest.skus)
  return _s;
}
inline const ::std::string& CheckAvailabilityRequest::skus(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.CheckAvailabilityRequest.skus)
  return _internal_skus().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL CheckAvailabilityRequest::mutable_skus(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:inventory.CheckAvailabilityRequest.skus)
  return _internal_mutable_skus()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void CheckAvailabilityRequest::set_skus(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_skus()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:inventory.CheckAvailabilityRequest.skus)
}
template <typename Arg_, typename... Args_>
inline void CheckAvailabilityRequest::add_skus(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(
      ::google::protobuf::MessageLite::internal_visibility(), GetArena(),
      *_internal_mutable_skus(), ::std::forward<Arg_>(value),
      args... );
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:inventory.CheckAvailabilityRequest.skus)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& CheckAvailabilityRequest::skus()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:inventory.CheckAvailabilityRequest.skus)
  return _internal_skus();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
CheckAvailabilityRequest::mutable_skus() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:inventory.CheckAvailabilityRequest.skus)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_skus();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
CheckAvailabilityRequest::_internal_skus() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.skus_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
CheckAvailabilityRequest::_internal_mutable_skus() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.skus_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CheckAvailabilityResponse

// map<string, .inventory.StockLevel> items = 1;
inline int CheckAvailabilityResponse::_internal_items_size() const {
  return _internal_items().size();
}
inline int CheckAvailabilityResponse::items_size() const {
  return _internal_items_size();
}
inline void CheckAvailabilityResponse::clear_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.items_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::google::protobuf::Map<::std::string, ::inventory::StockLevel>& CheckAvailabilityResponse::_internal_items() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.items_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::inventory::StockLevel>& CheckAvailabilityResponse::items() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:inventory.CheckAvailabilityResponse.items)
  return _internal_items();
}
inline ::google::protobuf::Map<::std::string, ::inventory::StockLevel>* PROTOBUF_NONNULL CheckAvailabilityResponse::_internal_mutable_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.items_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::inventory::StockLevel>* PROTOBUF_NONNULL CheckAvailabilityResponse::mutable_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_map:inventory.CheckAvailabilityResponse.items)
  return _internal_mutable_items();
}

// -------------------------------------------------------------------

// StockLevel

// string sku = 1;
inline void StockLevel::clear_sku() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sku_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& StockLevel::sku() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.StockLevel.sku)
  return _internal_sku();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void StockLevel::set_sku(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.sku_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:inventory.StockLevel.sku)
}
inline ::std::string* PROTOBUF_NONNULL StockLevel::mutable_sku()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_sku();
  // @@protoc_insertion_point(field_mutable:inventory.StockLevel.sku)
  return _s;
}
inline const ::std::string& StockLevel::_internal_sku() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sku_.Get();
}
inline void StockLevel::_internal_set_sku(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sku_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL StockLevel::_internal_mutable_sku() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.sku_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE StockLevel::release_sku() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:inventory.StockLevel.sku)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.sku_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.sku_.Set("", GetArena());
  }
  return released;
}
inline void StockLevel::set_allocated_sku(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.sku_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.sku_.IsDefault()) {
    _impl_.sku_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:inventory.StockLevel.sku)
}

// string name = 2;
inline void StockLevel::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& StockLevel::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.StockLevel.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void StockLevel::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:inventory.StockLevel.name)
}
inline ::std::string* PROTOBUF_NONNULL StockLevel::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inventory.StockLevel.name)
  return _s;
}
inline const ::std::string& StockLevel::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void StockLevel::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL StockLevel::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE StockLevel::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:inventory.StockLevel.name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void StockLevel::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:inventory.StockLevel.name)
}

// string aisle_type = 3;
inline void StockLevel::clear_aisle_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aisle_type_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::std::string& StockLevel::aisle_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.StockLevel.aisle_type)
  return _internal_aisle_type();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void StockLevel::set_aisle_type(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  _impl_.aisle_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:inventory.StockLevel.aisle_type)
}
inline ::std::string* PROTOBUF_NONNULL StockLevel::mutable_aisle_type()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::std::string* _s = _internal_mutable_aisle_type();
  // @@protoc_insertion_point(field_mutable:inventory.StockLevel.aisle_type)
  return _s;
}
inline const ::std::string& StockLevel::_internal_aisle_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.aisle_type_.Get();
}
inline void StockLevel::_internal_set_aisle_type(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aisle_type_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL StockLevel::_internal_mutable_aisle_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.aisle_type_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE StockLevel::release_aisle_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:inventory.StockLevel.aisle_type)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000004U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  auto* released = _impl_.aisle_type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.aisle_type_.Set("", GetArena());
  }
  return released;
}
inline void StockLevel::set_allocated_aisle_type(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  _impl_.aisle_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.aisle_type_.IsDefault()) {
    _impl_.aisle_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:inventory.StockLevel.aisle_type)
}

// int32 quantity_available = 4;
inline void StockLevel::clear_quantity_available() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quantity_available_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::int32_t StockLevel::quantity_available() const {
  // @@protoc_insertion_point(field_get:inventory.StockLevel.quantity_available)
  return _internal_quantity_available();
}
inline void StockLevel::set_quantity_available(::int32_t value) {
  _internal_set_quantity_available(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:inventory.StockLevel.quantity_available)
}
inline ::int32_t StockLevel::_internal_quantity_available() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.quantity_available_;
}
inline void StockLevel::_internal_set_quantity_available(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quantity_available_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ReserveItemsRequest

// string order_id = 1;
inline void ReserveItemsRequest::clear_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.order_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& ReserveItemsRequest::order_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.ReserveItemsRequest.order_id)
  return _internal_order_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ReserveItemsRequest::set_order_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.order_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:inventory.ReserveItemsRequest.order_id)
}
inline ::std::string* PROTOBUF_NONNULL ReserveItemsRequest::mutable_order_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_order_id();
  // @@protoc_insertion_point(field_mutable:inventory.ReserveItemsRequest.order_id)
  return _s;
}
inline const ::std::string& ReserveItemsRequest::_internal_order_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.order_id_.Get();
}
inline void ReserveItemsRequest::_internal_set_order_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.order_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ReserveItemsRequest::_internal_mutable_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.order_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ReserveItemsRequest::release_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:inventory.ReserveItemsRequest.order_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.order_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.order_id_.Set("", GetArena());
  }
  return released;
}
inline void ReserveItemsRequest::set_allocated_order_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.order_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.order_id_.IsDefault()) {
    _impl_.order_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:inventory.ReserveItemsRequest.order_id)
}

// map<string, int32> items = 2;
inline int ReserveItemsRequest::_internal_items_size() const {
  return _internal_items().size();
}
inline int ReserveItemsRequest::items_size() const {
  return _internal_items_size();
}
inline void ReserveItemsRequest::clear_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.items_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::google::protobuf::Map<::std::string, ::int32_t>& ReserveItemsRequest::_internal_items() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.items_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::int32_t>& ReserveItemsRequest::items() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:inventory.ReserveItemsRequest.items)
  return _internal_items();
}
inline ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL ReserveItemsRequest::_internal_mutable_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.items_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL ReserveItemsRequest::mutable_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_map:inventory.ReserveItemsRequest.items)
  return _internal_mutable_items();
}

// -------------------------------------------------------------------

// ReserveItemsResponse

// string order_id = 1;
inline void ReserveItemsResponse::clear_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.order_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& ReserveItemsResponse::order_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.ReserveItemsResponse.order_id)
  return _internal_order_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ReserveItemsResponse::set_order_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.order_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:inventory.ReserveItemsResponse.order_id)
}
inline ::std::string* PROTOBUF_NONNULL ReserveItemsResponse::mutable_order_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_order_id();
  // @@protoc_insertion_point(field_mutable:inventory.ReserveItemsResponse.order_id)
  return _s;
}
inline const ::std::string& ReserveItemsResponse::_internal_order_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.order_id_.Get();
}
inline void ReserveItemsResponse::_internal_set_order_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.order_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ReserveItemsResponse::_internal_mutable_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.order_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ReserveItemsResponse::release_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:inventory.ReserveItemsResponse.order_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.order_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.order_id_.Set("", GetArena());
  }
  return released;
}
inline void ReserveItemsResponse::set_allocated_order_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.order_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.order_id_.IsDefault()) {
    _impl_.order_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:inventory.ReserveItemsResponse.order_id)
}

// bool success = 2;
inline void ReserveItemsResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline bool ReserveItemsResponse::success() const {
  // @@protoc_insertion_point(field_get:inventory.ReserveItemsResponse.success)
  return _internal_success();
}
inline void ReserveItemsResponse::set_success(bool value) {
  _internal_set_success(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:inventory.ReserveItemsResponse.success)
}
inline bool ReserveItemsResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void ReserveItemsResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// string error_message = 3;
inline void ReserveItemsResponse::clear_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& ReserveItemsResponse::error_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.ReserveItemsResponse.error_message)
  return _internal_error_message();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ReserveItemsResponse::set_error_message(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.error_message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:inventory.ReserveItemsResponse.error_message)
}
inline ::std::string* PROTOBUF_NONNULL ReserveItemsResponse::mutable_error_message()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:inventory.ReserveItemsResponse.error_message)
  return _s;
}
inline const ::std::string& ReserveItemsResponse::_internal_error_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_message_.Get();
}
inline void ReserveItemsResponse::_internal_set_error_message(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ReserveItemsResponse::_internal_mutable_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.error_message_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ReserveItemsResponse::release_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:inventory.ReserveItemsResponse.error_message)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.error_message_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.error_message_.Set("", GetArena());
  }
  return released;
}
inline void ReserveItemsResponse::set_allocated_error_message(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.error_message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:inventory.ReserveItemsResponse.error_message)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ReleaseItemsRequest

// string order_id = 1;
inline void ReleaseItemsRequest::clear_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.order_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& ReleaseItemsRequest::order_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.ReleaseItemsRequest.order_id)
  return _internal_order_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ReleaseItemsRequest::set_order_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.order_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:inventory.ReleaseItemsRequest.order_id)
}
inline ::std::string* PROTOBUF_NONNULL ReleaseItemsRequest::mutable_order_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_order_id();
  // @@protoc_insertion_point(field_mutable:inventory.ReleaseItemsRequest.order_id)
  return _s;
}
inline const ::std::string& ReleaseItemsRequest::_internal_order_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.order_id_.Get();
}
inline void ReleaseItemsRequest::_internal_set_order_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.order_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ReleaseItemsRequest::_internal_mutable_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.order_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ReleaseItemsRequest::release_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:inventory.ReleaseItemsRequest.order_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.order_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.order_id_.Set("", GetArena());
  }
  return released;
}
inline void ReleaseItemsRequest::set_allocated_order_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.order_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.order_id_.IsDefault()) {
    _impl_.order_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:inventory.ReleaseItemsRequest.order_id)
}

// map<string, int32> items = 2;
inline int ReleaseItemsRequest::_internal_items_size() const {
  return _internal_items().size();
}
inline int ReleaseItemsRequest::items_size() const {
  return _internal_items_size();
}
inline void ReleaseItemsRequest::clear_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.items_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::google::protobuf::Map<::std::string, ::int32_t>& ReleaseItemsRequest::_internal_items() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.items_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::int32_t>& ReleaseItemsRequest::items() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:inventory.ReleaseItemsRequest.items)
  return _internal_items();
}
inline ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL ReleaseItemsRequest::_internal_mutable_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.items_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL ReleaseItemsRequest::mutable_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_map:inventory.ReleaseItemsRequest.items)
  return _internal_mutable_items();
}

// -------------------------------------------------------------------

// ReleaseItemsResponse

// bool success = 1;
inline void ReleaseItemsResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline bool ReleaseItemsResponse::success() const {
  // @@protoc_insertion_point(field_get:inventory.ReleaseItemsResponse.success)
  return _internal_success();
}
inline void ReleaseItemsResponse::set_success(bool value) {
  _internal_set_success(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:inventory.ReleaseItemsResponse.success)
}
inline bool ReleaseItemsResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void ReleaseItemsResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ProcessCustomerOrderRequest

// string order_id = 1;
inline void ProcessCustomerOrderRequest::clear_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.order_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& ProcessCustomerOrderRequest::order_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.ProcessCustomerOrderRequest.order_id)
  return _internal_order_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ProcessCustomerOrderRequest::set_order_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.order_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:inventory.ProcessCustomerOrderRequest.order_id)
}
inline ::std::string* PROTOBUF_NONNULL ProcessCustomerOrderRequest::mutable_order_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_order_id();
  // @@protoc_insertion_point(field_mutable:inventory.ProcessCustomerOrderRequest.order_id)
  return _s;
}
inline const ::std::string& ProcessCustomerOrderRequest::_internal_order_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.order_id_.Get();
}
inline void ProcessCustomerOrderRequest::_internal_set_order_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.order_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ProcessCustomerOrderRequest::_internal_mutable_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.order_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ProcessCustomerOrderRequest::release_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:inventory.ProcessCustomerOrderRequest.order_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.order_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.order_id_.Set("", GetArena());
  }
  return released;
}
inline void ProcessCustomerOrderRequest::set_allocated_order_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.order_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.order_id_.IsDefault()) {
    _impl_.order_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:inventory.ProcessCustomerOrderRequest.order_id)
}

// map<string, int32> items = 2;
inline int ProcessCustomerOrderRequest::_internal_items_size() const {
  return _internal_items().size();
}
inline int ProcessCustomerOrderRequest::items_size() const {
  return _internal_items_size();
}
inline void ProcessCustomerOrderRequest::clear_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.items_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::google::protobuf::Map<::std::string, ::int32_t>& ProcessCustomerOrderRequest::_internal_items() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.items_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::int32_t>& ProcessCustomerOrderRequest::items() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:inventory.ProcessCustomerOrderRequest.items)
  return _internal_items();
}
inline ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL ProcessCustomerOrderRequest::_internal_mutable_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.items_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL ProcessCustomerOrderRequest::mutable_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_map:inventory.ProcessCustomerOrderRequest.items)
  return _internal_mutable_items();
}

// -------------------------------------------------------------------

// ProcessCustomerOrderResponse

// bool success = 1;
inline void ProcessCustomerOrderResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline bool ProcessCustomerOrderResponse::success() const {
  // @@protoc_insertion_point(field_get:inventory.ProcessCustomerOrderResponse.success)
  return _internal_success();
}
inline void ProcessCustomerOrderResponse::set_success(bool value) {
  _internal_set_success(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:inventory.ProcessCustomerOrderResponse.success)
}
inline bool ProcessCustomerOrderResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void ProcessCustomerOrderResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// string message = 2;
inline void ProcessCustomerOrderResponse::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& ProcessCustomerOrderResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.ProcessCustomerOrderResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ProcessCustomerOrderResponse::set_message(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:inventory.ProcessCustomerOrderResponse.message)
}
inline ::std::string* PROTOBUF_NONNULL ProcessCustomerOrderResponse::mutable_message()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:inventory.ProcessCustomerOrderResponse.message)
  return _s;
}
inline const ::std::string& ProcessCustomerOrderResponse::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void ProcessCustomerOrderResponse::_internal_set_message(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ProcessCustomerOrderResponse::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.message_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ProcessCustomerOrderResponse::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:inventory.ProcessCustomerOrderResponse.message)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.message_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.message_.Set("", GetArena());
  }
  return released;
}
inline void ProcessCustomerOrderResponse::set_allocated_message(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:inventory.ProcessCustomerOrderResponse.message)
}

// -------------------------------------------------------------------

// RestockItem

// string sku = 1;
inline void RestockItem::clear_sku() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sku_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& RestockItem::sku() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.RestockItem.sku)
  return _internal_sku();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RestockItem::set_sku(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.sku_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:inventory.RestockItem.sku)
}
inline ::std::string* PROTOBUF_NONNULL RestockItem::mutable_sku()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_sku();
  // @@protoc_insertion_point(field_mutable:inventory.RestockItem.sku)
  return _s;
}
inline const ::std::string& RestockItem::_internal_sku() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sku_.Get();
}
inline void RestockItem::_internal_set_sku(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sku_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RestockItem::_internal_mutable_sku() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.sku_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RestockItem::release_sku() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:inventory.RestockItem.sku)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.sku_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.sku_.Set("", GetArena());
  }
  return released;
}
inline void RestockItem::set_allocated_sku(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.sku_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.sku_.IsDefault()) {
    _impl_.sku_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:inventory.RestockItem.sku)
}

// string name = 2;
inline void RestockItem::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& RestockItem::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.RestockItem.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RestockItem::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:inventory.RestockItem.name)
}
inline ::std::string* PROTOBUF_NONNULL RestockItem::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inventory.RestockItem.name)
  return _s;
}
inline const ::std::string& RestockItem::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void RestockItem::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RestockItem::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RestockItem::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:inventory.RestockItem.name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void RestockItem::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:inventory.RestockItem.name)
}

// string aisle_type = 3;
inline void RestockItem::clear_aisle_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aisle_type_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::std::string& RestockItem::aisle_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.RestockItem.aisle_type)
  return _internal_aisle_type();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RestockItem::set_aisle_type(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  _impl_.aisle_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:inventory.RestockItem.aisle_type)
}
inline ::std::string* PROTOBUF_NONNULL RestockItem::mutable_aisle_type()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::std::string* _s = _internal_mutable_aisle_type();
  // @@protoc_insertion_point(field_mutable:inventory.RestockItem.aisle_type)
  return _s;
}
inline const ::std::string& RestockItem::_internal_aisle_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.aisle_type_.Get();
}
inline void RestockItem::_internal_set_aisle_type(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aisle_type_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RestockItem::_internal_mutable_aisle_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.aisle_type_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RestockItem::release_aisle_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:inventory.RestockItem.aisle_type)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000004U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  auto* released = _impl_.aisle_type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.aisle_type_.Set("", GetArena());
  }
  return released;
}
inline void RestockItem::set_allocated_aisle_type(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  _impl_.aisle_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.aisle_type_.IsDefault()) {
    _impl_.aisle_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:inventory.RestockItem.aisle_type)
}

// int32 quantity = 4;
inline void RestockItem::clear_quantity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quantity_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline ::int32_t RestockItem::quantity() const {
  // @@protoc_insertion_point(field_get:inventory.RestockItem.quantity)
  return _internal_quantity();
}
inline void RestockItem::set_quantity(::int32_t value) {
  _internal_set_quantity(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  // @@protoc_insertion_point(field_set:inventory.RestockItem.quantity)
}
inline ::int32_t RestockItem::_internal_quantity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.quantity_;
}
inline void RestockItem::_internal_set_quantity(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quantity_ = value;
}

// double unit_cost = 5;
inline void RestockItem::clear_unit_cost() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unit_cost_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline double RestockItem::unit_cost() const {
  // @@protoc_insertion_point(field_get:inventory.RestockItem.unit_cost)
  return _internal_unit_cost();
}
inline void RestockItem::set_unit_cost(double value) {
  _internal_set_unit_cost(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:inventory.RestockItem.unit_cost)
}
inline double RestockItem::_internal_unit_cost() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.unit_cost_;
}
inline void RestockItem::_internal_set_unit_cost(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unit_cost_ = value;
}

// .google.protobuf.Timestamp mfd_date = 6;
inline bool RestockItem::has_mfd_date() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.mfd_date_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& RestockItem::_internal_mfd_date() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.mfd_date_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& RestockItem::mfd_date() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.RestockItem.mfd_date)
  return _internal_mfd_date();
}
inline void RestockItem::unsafe_arena_set_allocated_mfd_date(
    ::google::protobuf::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mfd_date_);
  }
  _impl_.mfd_date_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inventory.RestockItem.mfd_date)
}
inline ::google::protobuf::Timestamp* PROTOBUF_NULLABLE RestockItem::release_mfd_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::google::protobuf::Timestamp* released = _impl_.mfd_date_;
  _impl_.mfd_date_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NULLABLE RestockItem::unsafe_arena_release_mfd_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:inventory.RestockItem.mfd_date)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::google::protobuf::Timestamp* temp = _impl_.mfd_date_;
  _impl_.mfd_date_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NONNULL RestockItem::_internal_mutable_mfd_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.mfd_date_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.mfd_date_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.mfd_date_;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NONNULL RestockItem::mutable_mfd_date()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::google::protobuf::Timestamp* _msg = _internal_mutable_mfd_date();
  // @@protoc_insertion_point(field_mutable:inventory.RestockItem.mfd_date)
  return _msg;
}
inline void RestockItem::set_allocated_mfd_date(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mfd_date_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.mfd_date_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:inventory.RestockItem.mfd_date)
}

// .google.protobuf.Timestamp expiry_date = 7;
inline bool RestockItem::has_expiry_date() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  PROTOBUF_ASSUME(!value || _impl_.expiry_date_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& RestockItem::_internal_expiry_date() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.expiry_date_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& RestockItem::expiry_date() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.RestockItem.expiry_date)
  return _internal_expiry_date();
}
inline void RestockItem::unsafe_arena_set_allocated_expiry_date(
    ::google::protobuf::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.expiry_date_);
  }
  _impl_.expiry_date_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inventory.RestockItem.expiry_date)
}
inline ::google::protobuf::Timestamp* PROTOBUF_NULLABLE RestockItem::release_expiry_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::google::protobuf::Timestamp* released = _impl_.expiry_date_;
  _impl_.expiry_date_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NULLABLE RestockItem::unsafe_arena_release_expiry_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:inventory.RestockItem.expiry_date)

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::google::protobuf::Timestamp* temp = _impl_.expiry_date_;
  _impl_.expiry_date_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NONNULL RestockItem::_internal_mutable_expiry_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.expiry_date_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.expiry_date_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.expiry_date_;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NONNULL RestockItem::mutable_expiry_date()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::google::protobuf::Timestamp* _msg = _internal_mutable_expiry_date();
  // @@protoc_insertion_point(field_mutable:inventory.RestockItem.expiry_date)
  return _msg;
}
inline void RestockItem::set_allocated_expiry_date(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.expiry_date_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }

  _impl_.expiry_date_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:inventory.RestockItem.expiry_date)
}

// -------------------------------------------------------------------

// RestockItemsOrderRequest

// string order_id = 1;
inline void RestockItemsOrderRequest::clear_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.order_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& RestockItemsOrderRequest::order_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.RestockItemsOrderRequest.order_id)
  return _internal_order_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RestockItemsOrderRequest::set_order_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.order_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:inventory.RestockItemsOrderRequest.order_id)
}
inline ::std::string* PROTOBUF_NONNULL RestockItemsOrderRequest::mutable_order_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_order_id();
  // @@protoc_insertion_point(field_mutable:inventory.RestockItemsOrderRequest.order_id)
  return _s;
}
inline const ::std::string& RestockItemsOrderRequest::_internal_order_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.order_id_.Get();
}
inline void RestockItemsOrderRequest::_internal_set_order_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.order_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RestockItemsOrderRequest::_internal_mutable_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.order_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RestockItemsOrderRequest::release_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:inventory.RestockItemsOrderRequest.order_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.order_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.order_id_.Set("", GetArena());
  }
  return released;
}
inline void RestockItemsOrderRequest::set_allocated_order_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.order_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.order_id_.IsDefault()) {
    _impl_.order_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:inventory.RestockItemsOrderRequest.order_id)
}

// repeated .inventory.RestockItem items = 2;
inline int RestockItemsOrderRequest::_internal_items_size() const {
  return _internal_items().size();
}
inline int RestockItemsOrderRequest::items_size() const {
  return _internal_items_size();
}
inline void RestockItemsOrderRequest::clear_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.items_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::inventory::RestockItem* PROTOBUF_NONNULL RestockItemsOrderRequest::mutable_items(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:inventory.RestockItemsOrderRequest.items)
  return _internal_mutable_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::inventory::RestockItem>* PROTOBUF_NONNULL RestockItemsOrderRequest::mutable_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:inventory.RestockItemsOrderRequest.items)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_items();
}
inline const ::inventory::RestockItem& RestockItemsOrderRequest::items(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.RestockItemsOrderRequest.items)
  return _internal_items().Get(index);
}
inline ::inventory::RestockItem* PROTOBUF_NONNULL RestockItemsOrderRequest::add_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::inventory::RestockItem* _add =
      _internal_mutable_items()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:inventory.RestockItemsOrderRequest.items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::inventory::RestockItem>& RestockItemsOrderRequest::items() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:inventory.RestockItemsOrderRequest.items)
  return _internal_items();
}
inline const ::google::protobuf::RepeatedPtrField<::inventory::RestockItem>&
RestockItemsOrderRequest::_internal_items() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<::inventory::RestockItem>* PROTOBUF_NONNULL
RestockItemsOrderRequest::_internal_mutable_items() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.items_;
}

// -------------------------------------------------------------------

// RestockItemsOrderResponse

// bool success = 1;
inline void RestockItemsOrderResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline bool RestockItemsOrderResponse::success() const {
  // @@protoc_insertion_point(field_get:inventory.RestockItemsOrderResponse.success)
  return _internal_success();
}
inline void RestockItemsOrderResponse::set_success(bool value) {
  _internal_set_success(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:inventory.RestockItemsOrderResponse.success)
}
inline bool RestockItemsOrderResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void RestockItemsOrderResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ReportJobStatusRequest

// string order_id = 1;
inline void ReportJobStatusRequest::clear_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.order_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& ReportJobStatusRequest::order_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.ReportJobStatusRequest.order_id)
  return _internal_order_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ReportJobStatusRequest::set_order_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.order_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:inventory.ReportJobStatusRequest.order_id)
}
inline ::std::string* PROTOBUF_NONNULL ReportJobStatusRequest::mutable_order_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_order_id();
  // @@protoc_insertion_point(field_mutable:inventory.ReportJobStatusRequest.order_id)
  return _s;
}
inline const ::std::string& ReportJobStatusRequest::_internal_order_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.order_id_.Get();
}
inline void ReportJobStatusRequest::_internal_set_order_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.order_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ReportJobStatusRequest::_internal_mutable_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.order_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ReportJobStatusRequest::release_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:inventory.ReportJobStatusRequest.order_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.order_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.order_id_.Set("", GetArena());
  }
  return released;
}
inline void ReportJobStatusRequest::set_allocated_order_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.order_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.order_id_.IsDefault()) {
    _impl_.order_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:inventory.ReportJobStatusRequest.order_id)
}

// string status = 3;
inline void ReportJobStatusRequest::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& ReportJobStatusRequest::status() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.ReportJobStatusRequest.status)
  return _internal_status();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ReportJobStatusRequest::set_status(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.status_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:inventory.ReportJobStatusRequest.status)
}
inline ::std::string* PROTOBUF_NONNULL ReportJobStatusRequest::mutable_status()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:inventory.ReportJobStatusRequest.status)
  return _s;
}
inline const ::std::string& ReportJobStatusRequest::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.status_.Get();
}
inline void ReportJobStatusRequest::_internal_set_status(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ReportJobStatusRequest::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.status_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ReportJobStatusRequest::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:inventory.ReportJobStatusRequest.status)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.status_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.status_.Set("", GetArena());
  }
  return released;
}
inline void ReportJobStatusRequest::set_allocated_status(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.status_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:inventory.ReportJobStatusRequest.status)
}

// map<string, int32> processed_items = 4;
inline int ReportJobStatusRequest::_internal_processed_items_size() const {
  return _internal_processed_items().size();
}
inline int ReportJobStatusRequest::processed_items_size() const {
  return _internal_processed_items_size();
}
inline void ReportJobStatusRequest::clear_processed_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.processed_items_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::google::protobuf::Map<::std::string, ::int32_t>& ReportJobStatusRequest::_internal_processed_items() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.processed_items_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::int32_t>& ReportJobStatusRequest::processed_items() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:inventory.ReportJobStatusRequest.processed_items)
  return _internal_processed_items();
}
inline ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL ReportJobStatusRequest::_internal_mutable_processed_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.processed_items_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL ReportJobStatusRequest::mutable_processed_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_mutable_map:inventory.ReportJobStatusRequest.processed_items)
  return _internal_mutable_processed_items();
}

// string order_type = 5;
inline void ReportJobStatusRequest::clear_order_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.order_type_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::std::string& ReportJobStatusRequest::order_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.ReportJobStatusRequest.order_type)
  return _internal_order_type();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ReportJobStatusRequest::set_order_type(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  _impl_.order_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:inventory.ReportJobStatusRequest.order_type)
}
inline ::std::string* PROTOBUF_NONNULL ReportJobStatusRequest::mutable_order_type()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::std::string* _s = _internal_mutable_order_type();
  // @@protoc_insertion_point(field_mutable:inventory.ReportJobStatusRequest.order_type)
  return _s;
}
inline const ::std::string& ReportJobStatusRequest::_internal_order_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.order_type_.Get();
}
inline void ReportJobStatusRequest::_internal_set_order_type(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.order_type_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ReportJobStatusRequest::_internal_mutable_order_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.order_type_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ReportJobStatusRequest::release_order_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:inventory.ReportJobStatusRequest.order_type)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000004U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  auto* released = _impl_.order_type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.order_type_.Set("", GetArena());
  }
  return released;
}
inline void ReportJobStatusRequest::set_allocated_order_type(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  _impl_.order_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.order_type_.IsDefault()) {
    _impl_.order_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:inventory.ReportJobStatusRequest.order_type)
}

// -------------------------------------------------------------------

// ReportJobStatusResponse

// bool success = 1;
inline void ReportJobStatusResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline bool ReportJobStatusResponse::success() const {
  // @@protoc_insertion_point(field_get:inventory.ReportJobStatusResponse.success)
  return _internal_success();
}
inline void ReportJobStatusResponse::set_success(bool value) {
  _internal_set_success(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:inventory.ReportJobStatusResponse.success)
}
inline bool ReportJobStatusResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void ReportJobStatusResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace inventory


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // proto_2finventory_2eproto_2epb_2eh
