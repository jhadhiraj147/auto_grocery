// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: inventory.proto
// Protobuf C++ Version: 6.33.4

#ifndef inventory_2eproto_2epb_2eh
#define inventory_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6033004
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_type_handler.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_inventory_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_inventory_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_inventory_2eproto;
}  // extern "C"
namespace inventory {
class CheckAvailabilityRequest;
struct CheckAvailabilityRequestDefaultTypeInternal;
extern CheckAvailabilityRequestDefaultTypeInternal _CheckAvailabilityRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CheckAvailabilityRequest_class_data_;
class CheckAvailabilityResponse;
struct CheckAvailabilityResponseDefaultTypeInternal;
extern CheckAvailabilityResponseDefaultTypeInternal _CheckAvailabilityResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CheckAvailabilityResponse_class_data_;
class CheckAvailabilityResponse_ItemsEntry_DoNotUse;
struct CheckAvailabilityResponse_ItemsEntry_DoNotUseDefaultTypeInternal;
extern CheckAvailabilityResponse_ItemsEntry_DoNotUseDefaultTypeInternal _CheckAvailabilityResponse_ItemsEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CheckAvailabilityResponse_ItemsEntry_DoNotUse_class_data_;
class CheckoutRequest;
struct CheckoutRequestDefaultTypeInternal;
extern CheckoutRequestDefaultTypeInternal _CheckoutRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CheckoutRequest_class_data_;
class CheckoutRequest_ItemsEntry_DoNotUse;
struct CheckoutRequest_ItemsEntry_DoNotUseDefaultTypeInternal;
extern CheckoutRequest_ItemsEntry_DoNotUseDefaultTypeInternal _CheckoutRequest_ItemsEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CheckoutRequest_ItemsEntry_DoNotUse_class_data_;
class CheckoutResponse;
struct CheckoutResponseDefaultTypeInternal;
extern CheckoutResponseDefaultTypeInternal _CheckoutResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CheckoutResponse_class_data_;
class CheckoutResponse_ItemsEntry_DoNotUse;
struct CheckoutResponse_ItemsEntry_DoNotUseDefaultTypeInternal;
extern CheckoutResponse_ItemsEntry_DoNotUseDefaultTypeInternal _CheckoutResponse_ItemsEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CheckoutResponse_ItemsEntry_DoNotUse_class_data_;
class ItemDetail;
struct ItemDetailDefaultTypeInternal;
extern ItemDetailDefaultTypeInternal _ItemDetail_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ItemDetail_class_data_;
class ReleaseItemsRequest;
struct ReleaseItemsRequestDefaultTypeInternal;
extern ReleaseItemsRequestDefaultTypeInternal _ReleaseItemsRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReleaseItemsRequest_class_data_;
class ReleaseItemsRequest_ItemsEntry_DoNotUse;
struct ReleaseItemsRequest_ItemsEntry_DoNotUseDefaultTypeInternal;
extern ReleaseItemsRequest_ItemsEntry_DoNotUseDefaultTypeInternal _ReleaseItemsRequest_ItemsEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReleaseItemsRequest_ItemsEntry_DoNotUse_class_data_;
class ReleaseItemsResponse;
struct ReleaseItemsResponseDefaultTypeInternal;
extern ReleaseItemsResponseDefaultTypeInternal _ReleaseItemsResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReleaseItemsResponse_class_data_;
class ReportJobStatusRequest;
struct ReportJobStatusRequestDefaultTypeInternal;
extern ReportJobStatusRequestDefaultTypeInternal _ReportJobStatusRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReportJobStatusRequest_class_data_;
class ReportJobStatusRequest_ItemsEntry_DoNotUse;
struct ReportJobStatusRequest_ItemsEntry_DoNotUseDefaultTypeInternal;
extern ReportJobStatusRequest_ItemsEntry_DoNotUseDefaultTypeInternal _ReportJobStatusRequest_ItemsEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReportJobStatusRequest_ItemsEntry_DoNotUse_class_data_;
class ReportJobStatusResponse;
struct ReportJobStatusResponseDefaultTypeInternal;
extern ReportJobStatusResponseDefaultTypeInternal _ReportJobStatusResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReportJobStatusResponse_class_data_;
class ReserveItemsRequest;
struct ReserveItemsRequestDefaultTypeInternal;
extern ReserveItemsRequestDefaultTypeInternal _ReserveItemsRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReserveItemsRequest_class_data_;
class ReserveItemsRequest_ItemsEntry_DoNotUse;
struct ReserveItemsRequest_ItemsEntry_DoNotUseDefaultTypeInternal;
extern ReserveItemsRequest_ItemsEntry_DoNotUseDefaultTypeInternal _ReserveItemsRequest_ItemsEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReserveItemsRequest_ItemsEntry_DoNotUse_class_data_;
class ReserveItemsResponse;
struct ReserveItemsResponseDefaultTypeInternal;
extern ReserveItemsResponseDefaultTypeInternal _ReserveItemsResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReserveItemsResponse_class_data_;
class ReserveItemsResponse_ItemsEntry_DoNotUse;
struct ReserveItemsResponse_ItemsEntry_DoNotUseDefaultTypeInternal;
extern ReserveItemsResponse_ItemsEntry_DoNotUseDefaultTypeInternal _ReserveItemsResponse_ItemsEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReserveItemsResponse_ItemsEntry_DoNotUse_class_data_;
class RestockItem;
struct RestockItemDefaultTypeInternal;
extern RestockItemDefaultTypeInternal _RestockItem_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RestockItem_class_data_;
class RestockItemsRequest;
struct RestockItemsRequestDefaultTypeInternal;
extern RestockItemsRequestDefaultTypeInternal _RestockItemsRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RestockItemsRequest_class_data_;
class RestockItemsResponse;
struct RestockItemsResponseDefaultTypeInternal;
extern RestockItemsResponseDefaultTypeInternal _RestockItemsResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RestockItemsResponse_class_data_;
}  // namespace inventory
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace inventory {

// ===================================================================


// -------------------------------------------------------------------

class RestockItemsResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:inventory.RestockItemsResponse) */ {
 public:
  inline RestockItemsResponse() : RestockItemsResponse(nullptr) {}
  ~RestockItemsResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RestockItemsResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RestockItemsResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RestockItemsResponse(::google::protobuf::internal::ConstantInitialized);

  inline RestockItemsResponse(const RestockItemsResponse& from) : RestockItemsResponse(nullptr, from) {}
  inline RestockItemsResponse(RestockItemsResponse&& from) noexcept
      : RestockItemsResponse(nullptr, ::std::move(from)) {}
  inline RestockItemsResponse& operator=(const RestockItemsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RestockItemsResponse& operator=(RestockItemsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RestockItemsResponse& default_instance() {
    return *reinterpret_cast<const RestockItemsResponse*>(
        &_RestockItemsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(RestockItemsResponse& a, RestockItemsResponse& b) { a.Swap(&b); }
  inline void Swap(RestockItemsResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RestockItemsResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RestockItemsResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RestockItemsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RestockItemsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RestockItemsResponse& from) { RestockItemsResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RestockItemsResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "inventory.RestockItemsResponse"; }

  explicit RestockItemsResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RestockItemsResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RestockItemsResponse& from);
  RestockItemsResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RestockItemsResponse&& from) noexcept
      : RestockItemsResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:inventory.RestockItemsResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RestockItemsResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    bool success_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_inventory_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RestockItemsResponse_class_data_;
// -------------------------------------------------------------------

class RestockItem final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:inventory.RestockItem) */ {
 public:
  inline RestockItem() : RestockItem(nullptr) {}
  ~RestockItem() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RestockItem* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RestockItem));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RestockItem(::google::protobuf::internal::ConstantInitialized);

  inline RestockItem(const RestockItem& from) : RestockItem(nullptr, from) {}
  inline RestockItem(RestockItem&& from) noexcept
      : RestockItem(nullptr, ::std::move(from)) {}
  inline RestockItem& operator=(const RestockItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline RestockItem& operator=(RestockItem&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RestockItem& default_instance() {
    return *reinterpret_cast<const RestockItem*>(
        &_RestockItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(RestockItem& a, RestockItem& b) { a.Swap(&b); }
  inline void Swap(RestockItem* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RestockItem* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RestockItem* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RestockItem>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RestockItem& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RestockItem& from) { RestockItem::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RestockItem* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "inventory.RestockItem"; }

  explicit RestockItem(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RestockItem(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RestockItem& from);
  RestockItem(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RestockItem&& from) noexcept
      : RestockItem(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSkuFieldNumber = 1,
    kNameFieldNumber = 2,
    kAisleTypeFieldNumber = 3,
    kMfdDateFieldNumber = 5,
    kExpiryDateFieldNumber = 6,
    kQuantityFieldNumber = 4,
  };
  // string sku = 1;
  void clear_sku() ;
  const ::std::string& sku() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_sku(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_sku();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_sku();
  void set_allocated_sku(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_sku() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_sku(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_sku();

  public:
  // string name = 2;
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // string aisle_type = 3;
  void clear_aisle_type() ;
  const ::std::string& aisle_type() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_aisle_type(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_aisle_type();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_aisle_type();
  void set_allocated_aisle_type(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_aisle_type() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_aisle_type(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_aisle_type();

  public:
  // string mfd_date = 5;
  void clear_mfd_date() ;
  const ::std::string& mfd_date() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_mfd_date(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_mfd_date();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_mfd_date();
  void set_allocated_mfd_date(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_mfd_date() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_mfd_date(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_mfd_date();

  public:
  // string expiry_date = 6;
  void clear_expiry_date() ;
  const ::std::string& expiry_date() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_expiry_date(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_expiry_date();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_expiry_date();
  void set_allocated_expiry_date(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_expiry_date() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_expiry_date(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_expiry_date();

  public:
  // int32 quantity = 4;
  void clear_quantity() ;
  ::int32_t quantity() const;
  void set_quantity(::int32_t value);

  private:
  ::int32_t _internal_quantity() const;
  void _internal_set_quantity(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:inventory.RestockItem)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   0, 66,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RestockItem& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr sku_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr aisle_type_;
    ::google::protobuf::internal::ArenaStringPtr mfd_date_;
    ::google::protobuf::internal::ArenaStringPtr expiry_date_;
    ::int32_t quantity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_inventory_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RestockItem_class_data_;
// -------------------------------------------------------------------

class ReserveItemsResponse_ItemsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::int32_t,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_INT32> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>;
  ReserveItemsResponse_ItemsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReserveItemsResponse_ItemsEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit ReserveItemsResponse_ItemsEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_ReserveItemsResponse_ItemsEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_inventory_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 53,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull ReserveItemsResponse_ItemsEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class ReserveItemsRequest_ItemsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::int32_t,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_INT32> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>;
  ReserveItemsRequest_ItemsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReserveItemsRequest_ItemsEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit ReserveItemsRequest_ItemsEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_ReserveItemsRequest_ItemsEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_inventory_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 52,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull ReserveItemsRequest_ItemsEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class ReportJobStatusResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:inventory.ReportJobStatusResponse) */ {
 public:
  inline ReportJobStatusResponse() : ReportJobStatusResponse(nullptr) {}
  ~ReportJobStatusResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReportJobStatusResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReportJobStatusResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReportJobStatusResponse(::google::protobuf::internal::ConstantInitialized);

  inline ReportJobStatusResponse(const ReportJobStatusResponse& from) : ReportJobStatusResponse(nullptr, from) {}
  inline ReportJobStatusResponse(ReportJobStatusResponse&& from) noexcept
      : ReportJobStatusResponse(nullptr, ::std::move(from)) {}
  inline ReportJobStatusResponse& operator=(const ReportJobStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportJobStatusResponse& operator=(ReportJobStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReportJobStatusResponse& default_instance() {
    return *reinterpret_cast<const ReportJobStatusResponse*>(
        &_ReportJobStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(ReportJobStatusResponse& a, ReportJobStatusResponse& b) { a.Swap(&b); }
  inline void Swap(ReportJobStatusResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportJobStatusResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReportJobStatusResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReportJobStatusResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReportJobStatusResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReportJobStatusResponse& from) { ReportJobStatusResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReportJobStatusResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "inventory.ReportJobStatusResponse"; }

  explicit ReportJobStatusResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ReportJobStatusResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ReportJobStatusResponse& from);
  ReportJobStatusResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ReportJobStatusResponse&& from) noexcept
      : ReportJobStatusResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:inventory.ReportJobStatusResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ReportJobStatusResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    bool success_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_inventory_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ReportJobStatusResponse_class_data_;
// -------------------------------------------------------------------

class ReportJobStatusRequest_ItemsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::int32_t,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_INT32> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>;
  ReportJobStatusRequest_ItemsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReportJobStatusRequest_ItemsEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit ReportJobStatusRequest_ItemsEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_ReportJobStatusRequest_ItemsEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_inventory_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 55,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull ReportJobStatusRequest_ItemsEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class ReleaseItemsResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:inventory.ReleaseItemsResponse) */ {
 public:
  inline ReleaseItemsResponse() : ReleaseItemsResponse(nullptr) {}
  ~ReleaseItemsResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReleaseItemsResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReleaseItemsResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReleaseItemsResponse(::google::protobuf::internal::ConstantInitialized);

  inline ReleaseItemsResponse(const ReleaseItemsResponse& from) : ReleaseItemsResponse(nullptr, from) {}
  inline ReleaseItemsResponse(ReleaseItemsResponse&& from) noexcept
      : ReleaseItemsResponse(nullptr, ::std::move(from)) {}
  inline ReleaseItemsResponse& operator=(const ReleaseItemsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReleaseItemsResponse& operator=(ReleaseItemsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReleaseItemsResponse& default_instance() {
    return *reinterpret_cast<const ReleaseItemsResponse*>(
        &_ReleaseItemsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(ReleaseItemsResponse& a, ReleaseItemsResponse& b) { a.Swap(&b); }
  inline void Swap(ReleaseItemsResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReleaseItemsResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReleaseItemsResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReleaseItemsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReleaseItemsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReleaseItemsResponse& from) { ReleaseItemsResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReleaseItemsResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "inventory.ReleaseItemsResponse"; }

  explicit ReleaseItemsResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ReleaseItemsResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ReleaseItemsResponse& from);
  ReleaseItemsResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ReleaseItemsResponse&& from) noexcept
      : ReleaseItemsResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:inventory.ReleaseItemsResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ReleaseItemsResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    bool success_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_inventory_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ReleaseItemsResponse_class_data_;
// -------------------------------------------------------------------

class ReleaseItemsRequest_ItemsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::int32_t,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_INT32> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>;
  ReleaseItemsRequest_ItemsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReleaseItemsRequest_ItemsEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit ReleaseItemsRequest_ItemsEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_ReleaseItemsRequest_ItemsEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_inventory_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 52,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull ReleaseItemsRequest_ItemsEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class ItemDetail final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:inventory.ItemDetail) */ {
 public:
  inline ItemDetail() : ItemDetail(nullptr) {}
  ~ItemDetail() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ItemDetail* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ItemDetail));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ItemDetail(::google::protobuf::internal::ConstantInitialized);

  inline ItemDetail(const ItemDetail& from) : ItemDetail(nullptr, from) {}
  inline ItemDetail(ItemDetail&& from) noexcept
      : ItemDetail(nullptr, ::std::move(from)) {}
  inline ItemDetail& operator=(const ItemDetail& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemDetail& operator=(ItemDetail&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemDetail& default_instance() {
    return *reinterpret_cast<const ItemDetail*>(
        &_ItemDetail_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(ItemDetail& a, ItemDetail& b) { a.Swap(&b); }
  inline void Swap(ItemDetail* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemDetail* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemDetail* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ItemDetail>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ItemDetail& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ItemDetail& from) { ItemDetail::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ItemDetail* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "inventory.ItemDetail"; }

  explicit ItemDetail(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ItemDetail(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ItemDetail& from);
  ItemDetail(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ItemDetail&& from) noexcept
      : ItemDetail(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSkuFieldNumber = 1,
    kNameFieldNumber = 2,
    kAisleTypeFieldNumber = 3,
    kQuantityAvailableFieldNumber = 4,
  };
  // string sku = 1;
  void clear_sku() ;
  const ::std::string& sku() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_sku(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_sku();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_sku();
  void set_allocated_sku(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_sku() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_sku(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_sku();

  public:
  // string name = 2;
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // string aisle_type = 3;
  void clear_aisle_type() ;
  const ::std::string& aisle_type() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_aisle_type(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_aisle_type();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_aisle_type();
  void set_allocated_aisle_type(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_aisle_type() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_aisle_type(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_aisle_type();

  public:
  // int32 quantity_available = 4;
  void clear_quantity_available() ;
  ::int32_t quantity_available() const;
  void set_quantity_available(::int32_t value);

  private:
  ::int32_t _internal_quantity_available() const;
  void _internal_set_quantity_available(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:inventory.ItemDetail)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 46,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ItemDetail& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr sku_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr aisle_type_;
    ::int32_t quantity_available_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_inventory_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ItemDetail_class_data_;
// -------------------------------------------------------------------

class CheckoutResponse_ItemsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::int32_t,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_INT32> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>;
  CheckoutResponse_ItemsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CheckoutResponse_ItemsEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit CheckoutResponse_ItemsEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_CheckoutResponse_ItemsEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_inventory_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 49,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull CheckoutResponse_ItemsEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class CheckoutRequest_ItemsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::int32_t,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_INT32> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>;
  CheckoutRequest_ItemsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CheckoutRequest_ItemsEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit CheckoutRequest_ItemsEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_CheckoutRequest_ItemsEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_inventory_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 48,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull CheckoutRequest_ItemsEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class CheckAvailabilityRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:inventory.CheckAvailabilityRequest) */ {
 public:
  inline CheckAvailabilityRequest() : CheckAvailabilityRequest(nullptr) {}
  ~CheckAvailabilityRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CheckAvailabilityRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CheckAvailabilityRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CheckAvailabilityRequest(::google::protobuf::internal::ConstantInitialized);

  inline CheckAvailabilityRequest(const CheckAvailabilityRequest& from) : CheckAvailabilityRequest(nullptr, from) {}
  inline CheckAvailabilityRequest(CheckAvailabilityRequest&& from) noexcept
      : CheckAvailabilityRequest(nullptr, ::std::move(from)) {}
  inline CheckAvailabilityRequest& operator=(const CheckAvailabilityRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckAvailabilityRequest& operator=(CheckAvailabilityRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckAvailabilityRequest& default_instance() {
    return *reinterpret_cast<const CheckAvailabilityRequest*>(
        &_CheckAvailabilityRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(CheckAvailabilityRequest& a, CheckAvailabilityRequest& b) { a.Swap(&b); }
  inline void Swap(CheckAvailabilityRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckAvailabilityRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckAvailabilityRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CheckAvailabilityRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CheckAvailabilityRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CheckAvailabilityRequest& from) { CheckAvailabilityRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CheckAvailabilityRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "inventory.CheckAvailabilityRequest"; }

  explicit CheckAvailabilityRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CheckAvailabilityRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CheckAvailabilityRequest& from);
  CheckAvailabilityRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CheckAvailabilityRequest&& from) noexcept
      : CheckAvailabilityRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSkusFieldNumber = 1,
  };
  // repeated string skus = 1;
  int skus_size() const;
  private:
  int _internal_skus_size() const;

  public:
  void clear_skus() ;
  const ::std::string& skus(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_skus(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_skus(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_skus();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_skus(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& skus() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_skus();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_skus() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_skus();

  public:
  // @@protoc_insertion_point(class_scope:inventory.CheckAvailabilityRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 47,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CheckAvailabilityRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> skus_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_inventory_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CheckAvailabilityRequest_class_data_;
// -------------------------------------------------------------------

class RestockItemsRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:inventory.RestockItemsRequest) */ {
 public:
  inline RestockItemsRequest() : RestockItemsRequest(nullptr) {}
  ~RestockItemsRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RestockItemsRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RestockItemsRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RestockItemsRequest(::google::protobuf::internal::ConstantInitialized);

  inline RestockItemsRequest(const RestockItemsRequest& from) : RestockItemsRequest(nullptr, from) {}
  inline RestockItemsRequest(RestockItemsRequest&& from) noexcept
      : RestockItemsRequest(nullptr, ::std::move(from)) {}
  inline RestockItemsRequest& operator=(const RestockItemsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RestockItemsRequest& operator=(RestockItemsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RestockItemsRequest& default_instance() {
    return *reinterpret_cast<const RestockItemsRequest*>(
        &_RestockItemsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(RestockItemsRequest& a, RestockItemsRequest& b) { a.Swap(&b); }
  inline void Swap(RestockItemsRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RestockItemsRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RestockItemsRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RestockItemsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RestockItemsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RestockItemsRequest& from) { RestockItemsRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RestockItemsRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "inventory.RestockItemsRequest"; }

  explicit RestockItemsRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RestockItemsRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RestockItemsRequest& from);
  RestockItemsRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RestockItemsRequest&& from) noexcept
      : RestockItemsRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kItemsFieldNumber = 2,
    kSupplierIdFieldNumber = 1,
  };
  // repeated .inventory.RestockItem items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::inventory::RestockItem* PROTOBUF_NONNULL mutable_items(int index);
  ::google::protobuf::RepeatedPtrField<::inventory::RestockItem>* PROTOBUF_NONNULL mutable_items();

  private:
  const ::google::protobuf::RepeatedPtrField<::inventory::RestockItem>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<::inventory::RestockItem>* PROTOBUF_NONNULL _internal_mutable_items();
  public:
  const ::inventory::RestockItem& items(int index) const;
  ::inventory::RestockItem* PROTOBUF_NONNULL add_items();
  const ::google::protobuf::RepeatedPtrField<::inventory::RestockItem>& items() const;
  // string supplier_id = 1;
  void clear_supplier_id() ;
  const ::std::string& supplier_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_supplier_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_supplier_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_supplier_id();
  void set_allocated_supplier_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_supplier_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_supplier_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_supplier_id();

  public:
  // @@protoc_insertion_point(class_scope:inventory.RestockItemsRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 49,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RestockItemsRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::inventory::RestockItem > items_;
    ::google::protobuf::internal::ArenaStringPtr supplier_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_inventory_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RestockItemsRequest_class_data_;
// -------------------------------------------------------------------

class ReserveItemsResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:inventory.ReserveItemsResponse) */ {
 public:
  inline ReserveItemsResponse() : ReserveItemsResponse(nullptr) {}
  ~ReserveItemsResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReserveItemsResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReserveItemsResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReserveItemsResponse(::google::protobuf::internal::ConstantInitialized);

  inline ReserveItemsResponse(const ReserveItemsResponse& from) : ReserveItemsResponse(nullptr, from) {}
  inline ReserveItemsResponse(ReserveItemsResponse&& from) noexcept
      : ReserveItemsResponse(nullptr, ::std::move(from)) {}
  inline ReserveItemsResponse& operator=(const ReserveItemsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReserveItemsResponse& operator=(ReserveItemsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReserveItemsResponse& default_instance() {
    return *reinterpret_cast<const ReserveItemsResponse*>(
        &_ReserveItemsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(ReserveItemsResponse& a, ReserveItemsResponse& b) { a.Swap(&b); }
  inline void Swap(ReserveItemsResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReserveItemsResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReserveItemsResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReserveItemsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReserveItemsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReserveItemsResponse& from) { ReserveItemsResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReserveItemsResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "inventory.ReserveItemsResponse"; }

  explicit ReserveItemsResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ReserveItemsResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ReserveItemsResponse& from);
  ReserveItemsResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ReserveItemsResponse&& from) noexcept
      : ReserveItemsResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOrderIdFieldNumber = 1,
    kSuccessFieldNumber = 3,
    kItemsFieldNumber = 2,
  };
  // string order_id = 1;
  void clear_order_id() ;
  const ::std::string& order_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_order_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_order_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_order_id();
  void set_allocated_order_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_order_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_order_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_order_id();

  public:
  // bool success = 3;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // map<string, int32> items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  const ::google::protobuf::Map<::std::string, ::int32_t>& items() const;
  ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL mutable_items();

  private:
  const ::google::protobuf::Map<::std::string, ::int32_t>& _internal_items() const;
  ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL _internal_mutable_items();

  public:
  // @@protoc_insertion_point(class_scope:inventory.ReserveItemsResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 52,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ReserveItemsResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr order_id_;
    bool success_;
    ::google::protobuf::internal::MapField<ReserveItemsResponse_ItemsEntry_DoNotUse, ::std::string, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>
        items_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_inventory_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ReserveItemsResponse_class_data_;
// -------------------------------------------------------------------

class ReserveItemsRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:inventory.ReserveItemsRequest) */ {
 public:
  inline ReserveItemsRequest() : ReserveItemsRequest(nullptr) {}
  ~ReserveItemsRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReserveItemsRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReserveItemsRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReserveItemsRequest(::google::protobuf::internal::ConstantInitialized);

  inline ReserveItemsRequest(const ReserveItemsRequest& from) : ReserveItemsRequest(nullptr, from) {}
  inline ReserveItemsRequest(ReserveItemsRequest&& from) noexcept
      : ReserveItemsRequest(nullptr, ::std::move(from)) {}
  inline ReserveItemsRequest& operator=(const ReserveItemsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReserveItemsRequest& operator=(ReserveItemsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReserveItemsRequest& default_instance() {
    return *reinterpret_cast<const ReserveItemsRequest*>(
        &_ReserveItemsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(ReserveItemsRequest& a, ReserveItemsRequest& b) { a.Swap(&b); }
  inline void Swap(ReserveItemsRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReserveItemsRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReserveItemsRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReserveItemsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReserveItemsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReserveItemsRequest& from) { ReserveItemsRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReserveItemsRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "inventory.ReserveItemsRequest"; }

  explicit ReserveItemsRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ReserveItemsRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ReserveItemsRequest& from);
  ReserveItemsRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ReserveItemsRequest&& from) noexcept
      : ReserveItemsRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOrderIdFieldNumber = 1,
    kItemsFieldNumber = 2,
  };
  // string order_id = 1;
  void clear_order_id() ;
  const ::std::string& order_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_order_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_order_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_order_id();
  void set_allocated_order_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_order_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_order_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_order_id();

  public:
  // map<string, int32> items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  const ::google::protobuf::Map<::std::string, ::int32_t>& items() const;
  ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL mutable_items();

  private:
  const ::google::protobuf::Map<::std::string, ::int32_t>& _internal_items() const;
  ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL _internal_mutable_items();

  public:
  // @@protoc_insertion_point(class_scope:inventory.ReserveItemsRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 2,
                                   1, 51,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ReserveItemsRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr order_id_;
    ::google::protobuf::internal::MapField<ReserveItemsRequest_ItemsEntry_DoNotUse, ::std::string, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>
        items_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_inventory_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ReserveItemsRequest_class_data_;
// -------------------------------------------------------------------

class ReportJobStatusRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:inventory.ReportJobStatusRequest) */ {
 public:
  inline ReportJobStatusRequest() : ReportJobStatusRequest(nullptr) {}
  ~ReportJobStatusRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReportJobStatusRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReportJobStatusRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReportJobStatusRequest(::google::protobuf::internal::ConstantInitialized);

  inline ReportJobStatusRequest(const ReportJobStatusRequest& from) : ReportJobStatusRequest(nullptr, from) {}
  inline ReportJobStatusRequest(ReportJobStatusRequest&& from) noexcept
      : ReportJobStatusRequest(nullptr, ::std::move(from)) {}
  inline ReportJobStatusRequest& operator=(const ReportJobStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportJobStatusRequest& operator=(ReportJobStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReportJobStatusRequest& default_instance() {
    return *reinterpret_cast<const ReportJobStatusRequest*>(
        &_ReportJobStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(ReportJobStatusRequest& a, ReportJobStatusRequest& b) { a.Swap(&b); }
  inline void Swap(ReportJobStatusRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportJobStatusRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReportJobStatusRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReportJobStatusRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReportJobStatusRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReportJobStatusRequest& from) { ReportJobStatusRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReportJobStatusRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "inventory.ReportJobStatusRequest"; }

  explicit ReportJobStatusRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ReportJobStatusRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ReportJobStatusRequest& from);
  ReportJobStatusRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ReportJobStatusRequest&& from) noexcept
      : ReportJobStatusRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOrderIdFieldNumber = 1,
    kRobotIdFieldNumber = 2,
    kStatusFieldNumber = 3,
    kItemsFieldNumber = 4,
  };
  // string order_id = 1;
  void clear_order_id() ;
  const ::std::string& order_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_order_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_order_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_order_id();
  void set_allocated_order_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_order_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_order_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_order_id();

  public:
  // string robot_id = 2;
  void clear_robot_id() ;
  const ::std::string& robot_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_robot_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_robot_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_robot_id();
  void set_allocated_robot_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_robot_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_robot_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_robot_id();

  public:
  // string status = 3;
  void clear_status() ;
  const ::std::string& status() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_status(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_status();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_status();
  void set_allocated_status(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_status() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_status(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_status();

  public:
  // map<string, int32> items = 4;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  const ::google::protobuf::Map<::std::string, ::int32_t>& items() const;
  ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL mutable_items();

  private:
  const ::google::protobuf::Map<::std::string, ::int32_t>& _internal_items() const;
  ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL _internal_mutable_items();

  public:
  // @@protoc_insertion_point(class_scope:inventory.ReportJobStatusRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   1, 68,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ReportJobStatusRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr order_id_;
    ::google::protobuf::internal::ArenaStringPtr robot_id_;
    ::google::protobuf::internal::ArenaStringPtr status_;
    ::google::protobuf::internal::MapField<ReportJobStatusRequest_ItemsEntry_DoNotUse, ::std::string, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>
        items_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_inventory_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ReportJobStatusRequest_class_data_;
// -------------------------------------------------------------------

class ReleaseItemsRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:inventory.ReleaseItemsRequest) */ {
 public:
  inline ReleaseItemsRequest() : ReleaseItemsRequest(nullptr) {}
  ~ReleaseItemsRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReleaseItemsRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReleaseItemsRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReleaseItemsRequest(::google::protobuf::internal::ConstantInitialized);

  inline ReleaseItemsRequest(const ReleaseItemsRequest& from) : ReleaseItemsRequest(nullptr, from) {}
  inline ReleaseItemsRequest(ReleaseItemsRequest&& from) noexcept
      : ReleaseItemsRequest(nullptr, ::std::move(from)) {}
  inline ReleaseItemsRequest& operator=(const ReleaseItemsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReleaseItemsRequest& operator=(ReleaseItemsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReleaseItemsRequest& default_instance() {
    return *reinterpret_cast<const ReleaseItemsRequest*>(
        &_ReleaseItemsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(ReleaseItemsRequest& a, ReleaseItemsRequest& b) { a.Swap(&b); }
  inline void Swap(ReleaseItemsRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReleaseItemsRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReleaseItemsRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReleaseItemsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReleaseItemsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReleaseItemsRequest& from) { ReleaseItemsRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReleaseItemsRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "inventory.ReleaseItemsRequest"; }

  explicit ReleaseItemsRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ReleaseItemsRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ReleaseItemsRequest& from);
  ReleaseItemsRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ReleaseItemsRequest&& from) noexcept
      : ReleaseItemsRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOrderIdFieldNumber = 1,
    kItemsFieldNumber = 2,
  };
  // string order_id = 1;
  void clear_order_id() ;
  const ::std::string& order_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_order_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_order_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_order_id();
  void set_allocated_order_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_order_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_order_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_order_id();

  public:
  // map<string, int32> items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  const ::google::protobuf::Map<::std::string, ::int32_t>& items() const;
  ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL mutable_items();

  private:
  const ::google::protobuf::Map<::std::string, ::int32_t>& _internal_items() const;
  ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL _internal_mutable_items();

  public:
  // @@protoc_insertion_point(class_scope:inventory.ReleaseItemsRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 2,
                                   1, 51,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ReleaseItemsRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr order_id_;
    ::google::protobuf::internal::MapField<ReleaseItemsRequest_ItemsEntry_DoNotUse, ::std::string, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>
        items_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_inventory_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ReleaseItemsRequest_class_data_;
// -------------------------------------------------------------------

class CheckoutResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:inventory.CheckoutResponse) */ {
 public:
  inline CheckoutResponse() : CheckoutResponse(nullptr) {}
  ~CheckoutResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CheckoutResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CheckoutResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CheckoutResponse(::google::protobuf::internal::ConstantInitialized);

  inline CheckoutResponse(const CheckoutResponse& from) : CheckoutResponse(nullptr, from) {}
  inline CheckoutResponse(CheckoutResponse&& from) noexcept
      : CheckoutResponse(nullptr, ::std::move(from)) {}
  inline CheckoutResponse& operator=(const CheckoutResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckoutResponse& operator=(CheckoutResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckoutResponse& default_instance() {
    return *reinterpret_cast<const CheckoutResponse*>(
        &_CheckoutResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(CheckoutResponse& a, CheckoutResponse& b) { a.Swap(&b); }
  inline void Swap(CheckoutResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckoutResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckoutResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CheckoutResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CheckoutResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CheckoutResponse& from) { CheckoutResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CheckoutResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "inventory.CheckoutResponse"; }

  explicit CheckoutResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CheckoutResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CheckoutResponse& from);
  CheckoutResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CheckoutResponse&& from) noexcept
      : CheckoutResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOrderIdFieldNumber = 1,
    kTotalPriceFieldNumber = 4,
    kSuccessFieldNumber = 3,
    kItemsFieldNumber = 2,
  };
  // string order_id = 1;
  void clear_order_id() ;
  const ::std::string& order_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_order_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_order_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_order_id();
  void set_allocated_order_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_order_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_order_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_order_id();

  public:
  // double total_price = 4;
  void clear_total_price() ;
  double total_price() const;
  void set_total_price(double value);

  private:
  double _internal_total_price() const;
  void _internal_set_total_price(double value);

  public:
  // bool success = 3;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // map<string, int32> items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  const ::google::protobuf::Map<::std::string, ::int32_t>& items() const;
  ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL mutable_items();

  private:
  const ::google::protobuf::Map<::std::string, ::int32_t>& _internal_items() const;
  ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL _internal_mutable_items();

  public:
  // @@protoc_insertion_point(class_scope:inventory.CheckoutResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   1, 48,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CheckoutResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr order_id_;
    double total_price_;
    bool success_;
    ::google::protobuf::internal::MapField<CheckoutResponse_ItemsEntry_DoNotUse, ::std::string, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>
        items_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_inventory_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CheckoutResponse_class_data_;
// -------------------------------------------------------------------

class CheckoutRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:inventory.CheckoutRequest) */ {
 public:
  inline CheckoutRequest() : CheckoutRequest(nullptr) {}
  ~CheckoutRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CheckoutRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CheckoutRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CheckoutRequest(::google::protobuf::internal::ConstantInitialized);

  inline CheckoutRequest(const CheckoutRequest& from) : CheckoutRequest(nullptr, from) {}
  inline CheckoutRequest(CheckoutRequest&& from) noexcept
      : CheckoutRequest(nullptr, ::std::move(from)) {}
  inline CheckoutRequest& operator=(const CheckoutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckoutRequest& operator=(CheckoutRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckoutRequest& default_instance() {
    return *reinterpret_cast<const CheckoutRequest*>(
        &_CheckoutRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(CheckoutRequest& a, CheckoutRequest& b) { a.Swap(&b); }
  inline void Swap(CheckoutRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckoutRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckoutRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CheckoutRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CheckoutRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CheckoutRequest& from) { CheckoutRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CheckoutRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "inventory.CheckoutRequest"; }

  explicit CheckoutRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CheckoutRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CheckoutRequest& from);
  CheckoutRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CheckoutRequest&& from) noexcept
      : CheckoutRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOrderIdFieldNumber = 1,
    kItemsFieldNumber = 2,
  };
  // string order_id = 1;
  void clear_order_id() ;
  const ::std::string& order_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_order_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_order_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_order_id();
  void set_allocated_order_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_order_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_order_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_order_id();

  public:
  // map<string, int32> items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  const ::google::protobuf::Map<::std::string, ::int32_t>& items() const;
  ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL mutable_items();

  private:
  const ::google::protobuf::Map<::std::string, ::int32_t>& _internal_items() const;
  ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL _internal_mutable_items();

  public:
  // @@protoc_insertion_point(class_scope:inventory.CheckoutRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 2,
                                   1, 47,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CheckoutRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr order_id_;
    ::google::protobuf::internal::MapField<CheckoutRequest_ItemsEntry_DoNotUse, ::std::string, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>
        items_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_inventory_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CheckoutRequest_class_data_;
// -------------------------------------------------------------------

class CheckAvailabilityResponse_ItemsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  CheckAvailabilityResponse_ItemsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CheckAvailabilityResponse_ItemsEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit CheckAvailabilityResponse_ItemsEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_CheckAvailabilityResponse_ItemsEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_inventory_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 58,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull CheckAvailabilityResponse_ItemsEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class CheckAvailabilityResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:inventory.CheckAvailabilityResponse) */ {
 public:
  inline CheckAvailabilityResponse() : CheckAvailabilityResponse(nullptr) {}
  ~CheckAvailabilityResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CheckAvailabilityResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CheckAvailabilityResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CheckAvailabilityResponse(::google::protobuf::internal::ConstantInitialized);

  inline CheckAvailabilityResponse(const CheckAvailabilityResponse& from) : CheckAvailabilityResponse(nullptr, from) {}
  inline CheckAvailabilityResponse(CheckAvailabilityResponse&& from) noexcept
      : CheckAvailabilityResponse(nullptr, ::std::move(from)) {}
  inline CheckAvailabilityResponse& operator=(const CheckAvailabilityResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckAvailabilityResponse& operator=(CheckAvailabilityResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckAvailabilityResponse& default_instance() {
    return *reinterpret_cast<const CheckAvailabilityResponse*>(
        &_CheckAvailabilityResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(CheckAvailabilityResponse& a, CheckAvailabilityResponse& b) { a.Swap(&b); }
  inline void Swap(CheckAvailabilityResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckAvailabilityResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckAvailabilityResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CheckAvailabilityResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CheckAvailabilityResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CheckAvailabilityResponse& from) { CheckAvailabilityResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CheckAvailabilityResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "inventory.CheckAvailabilityResponse"; }

  explicit CheckAvailabilityResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CheckAvailabilityResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CheckAvailabilityResponse& from);
  CheckAvailabilityResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CheckAvailabilityResponse&& from) noexcept
      : CheckAvailabilityResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kItemsFieldNumber = 1,
  };
  // map<string, .inventory.ItemDetail> items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  const ::google::protobuf::Map<::std::string, ::inventory::ItemDetail>& items() const;
  ::google::protobuf::Map<::std::string, ::inventory::ItemDetail>* PROTOBUF_NONNULL mutable_items();

  private:
  const ::google::protobuf::Map<::std::string, ::inventory::ItemDetail>& _internal_items() const;
  ::google::protobuf::Map<::std::string, ::inventory::ItemDetail>* PROTOBUF_NONNULL _internal_mutable_items();

  public:
  // @@protoc_insertion_point(class_scope:inventory.CheckAvailabilityResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   2, 49,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CheckAvailabilityResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<CheckAvailabilityResponse_ItemsEntry_DoNotUse, ::std::string, ::inventory::ItemDetail,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        items_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_inventory_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CheckAvailabilityResponse_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// CheckAvailabilityRequest

// repeated string skus = 1;
inline int CheckAvailabilityRequest::_internal_skus_size() const {
  return _internal_skus().size();
}
inline int CheckAvailabilityRequest::skus_size() const {
  return _internal_skus_size();
}
inline void CheckAvailabilityRequest::clear_skus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.skus_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::std::string* PROTOBUF_NONNULL CheckAvailabilityRequest::add_skus()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s =
      _internal_mutable_skus()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add_mutable:inventory.CheckAvailabilityRequest.skus)
  return _s;
}
inline const ::std::string& CheckAvailabilityRequest::skus(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.CheckAvailabilityRequest.skus)
  return _internal_skus().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL CheckAvailabilityRequest::mutable_skus(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:inventory.CheckAvailabilityRequest.skus)
  return _internal_mutable_skus()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void CheckAvailabilityRequest::set_skus(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_skus()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:inventory.CheckAvailabilityRequest.skus)
}
template <typename Arg_, typename... Args_>
inline void CheckAvailabilityRequest::add_skus(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(
      ::google::protobuf::MessageLite::internal_visibility(), GetArena(),
      *_internal_mutable_skus(), ::std::forward<Arg_>(value),
      args... );
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:inventory.CheckAvailabilityRequest.skus)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& CheckAvailabilityRequest::skus()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:inventory.CheckAvailabilityRequest.skus)
  return _internal_skus();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
CheckAvailabilityRequest::mutable_skus() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:inventory.CheckAvailabilityRequest.skus)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_skus();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
CheckAvailabilityRequest::_internal_skus() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.skus_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
CheckAvailabilityRequest::_internal_mutable_skus() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.skus_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CheckAvailabilityResponse

// map<string, .inventory.ItemDetail> items = 1;
inline int CheckAvailabilityResponse::_internal_items_size() const {
  return _internal_items().size();
}
inline int CheckAvailabilityResponse::items_size() const {
  return _internal_items_size();
}
inline void CheckAvailabilityResponse::clear_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.items_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::google::protobuf::Map<::std::string, ::inventory::ItemDetail>& CheckAvailabilityResponse::_internal_items() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.items_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::inventory::ItemDetail>& CheckAvailabilityResponse::items() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:inventory.CheckAvailabilityResponse.items)
  return _internal_items();
}
inline ::google::protobuf::Map<::std::string, ::inventory::ItemDetail>* PROTOBUF_NONNULL CheckAvailabilityResponse::_internal_mutable_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.items_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::inventory::ItemDetail>* PROTOBUF_NONNULL CheckAvailabilityResponse::mutable_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_map:inventory.CheckAvailabilityResponse.items)
  return _internal_mutable_items();
}

// -------------------------------------------------------------------

// ItemDetail

// string sku = 1;
inline void ItemDetail::clear_sku() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sku_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& ItemDetail::sku() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.ItemDetail.sku)
  return _internal_sku();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ItemDetail::set_sku(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.sku_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:inventory.ItemDetail.sku)
}
inline ::std::string* PROTOBUF_NONNULL ItemDetail::mutable_sku()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_sku();
  // @@protoc_insertion_point(field_mutable:inventory.ItemDetail.sku)
  return _s;
}
inline const ::std::string& ItemDetail::_internal_sku() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sku_.Get();
}
inline void ItemDetail::_internal_set_sku(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sku_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ItemDetail::_internal_mutable_sku() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.sku_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ItemDetail::release_sku() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:inventory.ItemDetail.sku)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.sku_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.sku_.Set("", GetArena());
  }
  return released;
}
inline void ItemDetail::set_allocated_sku(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.sku_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.sku_.IsDefault()) {
    _impl_.sku_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:inventory.ItemDetail.sku)
}

// string name = 2;
inline void ItemDetail::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& ItemDetail::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.ItemDetail.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ItemDetail::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:inventory.ItemDetail.name)
}
inline ::std::string* PROTOBUF_NONNULL ItemDetail::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inventory.ItemDetail.name)
  return _s;
}
inline const ::std::string& ItemDetail::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void ItemDetail::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ItemDetail::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ItemDetail::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:inventory.ItemDetail.name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void ItemDetail::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:inventory.ItemDetail.name)
}

// string aisle_type = 3;
inline void ItemDetail::clear_aisle_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aisle_type_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::std::string& ItemDetail::aisle_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.ItemDetail.aisle_type)
  return _internal_aisle_type();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ItemDetail::set_aisle_type(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  _impl_.aisle_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:inventory.ItemDetail.aisle_type)
}
inline ::std::string* PROTOBUF_NONNULL ItemDetail::mutable_aisle_type()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::std::string* _s = _internal_mutable_aisle_type();
  // @@protoc_insertion_point(field_mutable:inventory.ItemDetail.aisle_type)
  return _s;
}
inline const ::std::string& ItemDetail::_internal_aisle_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.aisle_type_.Get();
}
inline void ItemDetail::_internal_set_aisle_type(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aisle_type_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ItemDetail::_internal_mutable_aisle_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.aisle_type_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ItemDetail::release_aisle_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:inventory.ItemDetail.aisle_type)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000004U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  auto* released = _impl_.aisle_type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.aisle_type_.Set("", GetArena());
  }
  return released;
}
inline void ItemDetail::set_allocated_aisle_type(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  _impl_.aisle_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.aisle_type_.IsDefault()) {
    _impl_.aisle_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:inventory.ItemDetail.aisle_type)
}

// int32 quantity_available = 4;
inline void ItemDetail::clear_quantity_available() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quantity_available_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::int32_t ItemDetail::quantity_available() const {
  // @@protoc_insertion_point(field_get:inventory.ItemDetail.quantity_available)
  return _internal_quantity_available();
}
inline void ItemDetail::set_quantity_available(::int32_t value) {
  _internal_set_quantity_available(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:inventory.ItemDetail.quantity_available)
}
inline ::int32_t ItemDetail::_internal_quantity_available() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.quantity_available_;
}
inline void ItemDetail::_internal_set_quantity_available(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quantity_available_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ReserveItemsRequest

// string order_id = 1;
inline void ReserveItemsRequest::clear_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.order_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& ReserveItemsRequest::order_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.ReserveItemsRequest.order_id)
  return _internal_order_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ReserveItemsRequest::set_order_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.order_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:inventory.ReserveItemsRequest.order_id)
}
inline ::std::string* PROTOBUF_NONNULL ReserveItemsRequest::mutable_order_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_order_id();
  // @@protoc_insertion_point(field_mutable:inventory.ReserveItemsRequest.order_id)
  return _s;
}
inline const ::std::string& ReserveItemsRequest::_internal_order_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.order_id_.Get();
}
inline void ReserveItemsRequest::_internal_set_order_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.order_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ReserveItemsRequest::_internal_mutable_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.order_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ReserveItemsRequest::release_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:inventory.ReserveItemsRequest.order_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.order_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.order_id_.Set("", GetArena());
  }
  return released;
}
inline void ReserveItemsRequest::set_allocated_order_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.order_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.order_id_.IsDefault()) {
    _impl_.order_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:inventory.ReserveItemsRequest.order_id)
}

// map<string, int32> items = 2;
inline int ReserveItemsRequest::_internal_items_size() const {
  return _internal_items().size();
}
inline int ReserveItemsRequest::items_size() const {
  return _internal_items_size();
}
inline void ReserveItemsRequest::clear_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.items_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::google::protobuf::Map<::std::string, ::int32_t>& ReserveItemsRequest::_internal_items() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.items_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::int32_t>& ReserveItemsRequest::items() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:inventory.ReserveItemsRequest.items)
  return _internal_items();
}
inline ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL ReserveItemsRequest::_internal_mutable_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.items_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL ReserveItemsRequest::mutable_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_map:inventory.ReserveItemsRequest.items)
  return _internal_mutable_items();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ReserveItemsResponse

// string order_id = 1;
inline void ReserveItemsResponse::clear_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.order_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& ReserveItemsResponse::order_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.ReserveItemsResponse.order_id)
  return _internal_order_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ReserveItemsResponse::set_order_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.order_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:inventory.ReserveItemsResponse.order_id)
}
inline ::std::string* PROTOBUF_NONNULL ReserveItemsResponse::mutable_order_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_order_id();
  // @@protoc_insertion_point(field_mutable:inventory.ReserveItemsResponse.order_id)
  return _s;
}
inline const ::std::string& ReserveItemsResponse::_internal_order_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.order_id_.Get();
}
inline void ReserveItemsResponse::_internal_set_order_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.order_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ReserveItemsResponse::_internal_mutable_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.order_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ReserveItemsResponse::release_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:inventory.ReserveItemsResponse.order_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.order_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.order_id_.Set("", GetArena());
  }
  return released;
}
inline void ReserveItemsResponse::set_allocated_order_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.order_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.order_id_.IsDefault()) {
    _impl_.order_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:inventory.ReserveItemsResponse.order_id)
}

// map<string, int32> items = 2;
inline int ReserveItemsResponse::_internal_items_size() const {
  return _internal_items().size();
}
inline int ReserveItemsResponse::items_size() const {
  return _internal_items_size();
}
inline void ReserveItemsResponse::clear_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.items_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::google::protobuf::Map<::std::string, ::int32_t>& ReserveItemsResponse::_internal_items() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.items_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::int32_t>& ReserveItemsResponse::items() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:inventory.ReserveItemsResponse.items)
  return _internal_items();
}
inline ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL ReserveItemsResponse::_internal_mutable_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.items_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL ReserveItemsResponse::mutable_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_mutable_map:inventory.ReserveItemsResponse.items)
  return _internal_mutable_items();
}

// bool success = 3;
inline void ReserveItemsResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline bool ReserveItemsResponse::success() const {
  // @@protoc_insertion_point(field_get:inventory.ReserveItemsResponse.success)
  return _internal_success();
}
inline void ReserveItemsResponse::set_success(bool value) {
  _internal_set_success(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:inventory.ReserveItemsResponse.success)
}
inline bool ReserveItemsResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void ReserveItemsResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ReleaseItemsRequest

// string order_id = 1;
inline void ReleaseItemsRequest::clear_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.order_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& ReleaseItemsRequest::order_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.ReleaseItemsRequest.order_id)
  return _internal_order_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ReleaseItemsRequest::set_order_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.order_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:inventory.ReleaseItemsRequest.order_id)
}
inline ::std::string* PROTOBUF_NONNULL ReleaseItemsRequest::mutable_order_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_order_id();
  // @@protoc_insertion_point(field_mutable:inventory.ReleaseItemsRequest.order_id)
  return _s;
}
inline const ::std::string& ReleaseItemsRequest::_internal_order_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.order_id_.Get();
}
inline void ReleaseItemsRequest::_internal_set_order_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.order_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ReleaseItemsRequest::_internal_mutable_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.order_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ReleaseItemsRequest::release_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:inventory.ReleaseItemsRequest.order_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.order_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.order_id_.Set("", GetArena());
  }
  return released;
}
inline void ReleaseItemsRequest::set_allocated_order_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.order_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.order_id_.IsDefault()) {
    _impl_.order_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:inventory.ReleaseItemsRequest.order_id)
}

// map<string, int32> items = 2;
inline int ReleaseItemsRequest::_internal_items_size() const {
  return _internal_items().size();
}
inline int ReleaseItemsRequest::items_size() const {
  return _internal_items_size();
}
inline void ReleaseItemsRequest::clear_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.items_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::google::protobuf::Map<::std::string, ::int32_t>& ReleaseItemsRequest::_internal_items() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.items_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::int32_t>& ReleaseItemsRequest::items() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:inventory.ReleaseItemsRequest.items)
  return _internal_items();
}
inline ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL ReleaseItemsRequest::_internal_mutable_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.items_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL ReleaseItemsRequest::mutable_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_map:inventory.ReleaseItemsRequest.items)
  return _internal_mutable_items();
}

// -------------------------------------------------------------------

// ReleaseItemsResponse

// bool success = 1;
inline void ReleaseItemsResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline bool ReleaseItemsResponse::success() const {
  // @@protoc_insertion_point(field_get:inventory.ReleaseItemsResponse.success)
  return _internal_success();
}
inline void ReleaseItemsResponse::set_success(bool value) {
  _internal_set_success(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:inventory.ReleaseItemsResponse.success)
}
inline bool ReleaseItemsResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void ReleaseItemsResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// -------------------------------------------------------------------

// RestockItemsRequest

// string supplier_id = 1;
inline void RestockItemsRequest::clear_supplier_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.supplier_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& RestockItemsRequest::supplier_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.RestockItemsRequest.supplier_id)
  return _internal_supplier_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RestockItemsRequest::set_supplier_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.supplier_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:inventory.RestockItemsRequest.supplier_id)
}
inline ::std::string* PROTOBUF_NONNULL RestockItemsRequest::mutable_supplier_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_supplier_id();
  // @@protoc_insertion_point(field_mutable:inventory.RestockItemsRequest.supplier_id)
  return _s;
}
inline const ::std::string& RestockItemsRequest::_internal_supplier_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.supplier_id_.Get();
}
inline void RestockItemsRequest::_internal_set_supplier_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.supplier_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RestockItemsRequest::_internal_mutable_supplier_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.supplier_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RestockItemsRequest::release_supplier_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:inventory.RestockItemsRequest.supplier_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.supplier_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.supplier_id_.Set("", GetArena());
  }
  return released;
}
inline void RestockItemsRequest::set_allocated_supplier_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.supplier_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.supplier_id_.IsDefault()) {
    _impl_.supplier_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:inventory.RestockItemsRequest.supplier_id)
}

// repeated .inventory.RestockItem items = 2;
inline int RestockItemsRequest::_internal_items_size() const {
  return _internal_items().size();
}
inline int RestockItemsRequest::items_size() const {
  return _internal_items_size();
}
inline void RestockItemsRequest::clear_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.items_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::inventory::RestockItem* PROTOBUF_NONNULL RestockItemsRequest::mutable_items(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:inventory.RestockItemsRequest.items)
  return _internal_mutable_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::inventory::RestockItem>* PROTOBUF_NONNULL RestockItemsRequest::mutable_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:inventory.RestockItemsRequest.items)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_items();
}
inline const ::inventory::RestockItem& RestockItemsRequest::items(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.RestockItemsRequest.items)
  return _internal_items().Get(index);
}
inline ::inventory::RestockItem* PROTOBUF_NONNULL RestockItemsRequest::add_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::inventory::RestockItem* _add =
      _internal_mutable_items()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:inventory.RestockItemsRequest.items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::inventory::RestockItem>& RestockItemsRequest::items() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:inventory.RestockItemsRequest.items)
  return _internal_items();
}
inline const ::google::protobuf::RepeatedPtrField<::inventory::RestockItem>&
RestockItemsRequest::_internal_items() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<::inventory::RestockItem>* PROTOBUF_NONNULL
RestockItemsRequest::_internal_mutable_items() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.items_;
}

// -------------------------------------------------------------------

// RestockItem

// string sku = 1;
inline void RestockItem::clear_sku() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sku_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& RestockItem::sku() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.RestockItem.sku)
  return _internal_sku();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RestockItem::set_sku(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.sku_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:inventory.RestockItem.sku)
}
inline ::std::string* PROTOBUF_NONNULL RestockItem::mutable_sku()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_sku();
  // @@protoc_insertion_point(field_mutable:inventory.RestockItem.sku)
  return _s;
}
inline const ::std::string& RestockItem::_internal_sku() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sku_.Get();
}
inline void RestockItem::_internal_set_sku(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sku_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RestockItem::_internal_mutable_sku() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.sku_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RestockItem::release_sku() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:inventory.RestockItem.sku)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.sku_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.sku_.Set("", GetArena());
  }
  return released;
}
inline void RestockItem::set_allocated_sku(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.sku_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.sku_.IsDefault()) {
    _impl_.sku_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:inventory.RestockItem.sku)
}

// string name = 2;
inline void RestockItem::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& RestockItem::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.RestockItem.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RestockItem::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:inventory.RestockItem.name)
}
inline ::std::string* PROTOBUF_NONNULL RestockItem::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inventory.RestockItem.name)
  return _s;
}
inline const ::std::string& RestockItem::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void RestockItem::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RestockItem::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RestockItem::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:inventory.RestockItem.name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void RestockItem::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:inventory.RestockItem.name)
}

// string aisle_type = 3;
inline void RestockItem::clear_aisle_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aisle_type_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::std::string& RestockItem::aisle_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.RestockItem.aisle_type)
  return _internal_aisle_type();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RestockItem::set_aisle_type(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  _impl_.aisle_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:inventory.RestockItem.aisle_type)
}
inline ::std::string* PROTOBUF_NONNULL RestockItem::mutable_aisle_type()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::std::string* _s = _internal_mutable_aisle_type();
  // @@protoc_insertion_point(field_mutable:inventory.RestockItem.aisle_type)
  return _s;
}
inline const ::std::string& RestockItem::_internal_aisle_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.aisle_type_.Get();
}
inline void RestockItem::_internal_set_aisle_type(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aisle_type_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RestockItem::_internal_mutable_aisle_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.aisle_type_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RestockItem::release_aisle_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:inventory.RestockItem.aisle_type)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000004U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  auto* released = _impl_.aisle_type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.aisle_type_.Set("", GetArena());
  }
  return released;
}
inline void RestockItem::set_allocated_aisle_type(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  _impl_.aisle_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.aisle_type_.IsDefault()) {
    _impl_.aisle_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:inventory.RestockItem.aisle_type)
}

// int32 quantity = 4;
inline void RestockItem::clear_quantity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quantity_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline ::int32_t RestockItem::quantity() const {
  // @@protoc_insertion_point(field_get:inventory.RestockItem.quantity)
  return _internal_quantity();
}
inline void RestockItem::set_quantity(::int32_t value) {
  _internal_set_quantity(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:inventory.RestockItem.quantity)
}
inline ::int32_t RestockItem::_internal_quantity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.quantity_;
}
inline void RestockItem::_internal_set_quantity(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quantity_ = value;
}

// string mfd_date = 5;
inline void RestockItem::clear_mfd_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mfd_date_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::std::string& RestockItem::mfd_date() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.RestockItem.mfd_date)
  return _internal_mfd_date();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RestockItem::set_mfd_date(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  _impl_.mfd_date_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:inventory.RestockItem.mfd_date)
}
inline ::std::string* PROTOBUF_NONNULL RestockItem::mutable_mfd_date()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::std::string* _s = _internal_mutable_mfd_date();
  // @@protoc_insertion_point(field_mutable:inventory.RestockItem.mfd_date)
  return _s;
}
inline const ::std::string& RestockItem::_internal_mfd_date() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.mfd_date_.Get();
}
inline void RestockItem::_internal_set_mfd_date(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mfd_date_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RestockItem::_internal_mutable_mfd_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.mfd_date_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RestockItem::release_mfd_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:inventory.RestockItem.mfd_date)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000008U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  auto* released = _impl_.mfd_date_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.mfd_date_.Set("", GetArena());
  }
  return released;
}
inline void RestockItem::set_allocated_mfd_date(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  _impl_.mfd_date_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.mfd_date_.IsDefault()) {
    _impl_.mfd_date_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:inventory.RestockItem.mfd_date)
}

// string expiry_date = 6;
inline void RestockItem::clear_expiry_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiry_date_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::std::string& RestockItem::expiry_date() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.RestockItem.expiry_date)
  return _internal_expiry_date();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RestockItem::set_expiry_date(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  _impl_.expiry_date_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:inventory.RestockItem.expiry_date)
}
inline ::std::string* PROTOBUF_NONNULL RestockItem::mutable_expiry_date()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::std::string* _s = _internal_mutable_expiry_date();
  // @@protoc_insertion_point(field_mutable:inventory.RestockItem.expiry_date)
  return _s;
}
inline const ::std::string& RestockItem::_internal_expiry_date() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.expiry_date_.Get();
}
inline void RestockItem::_internal_set_expiry_date(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiry_date_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RestockItem::_internal_mutable_expiry_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.expiry_date_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RestockItem::release_expiry_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:inventory.RestockItem.expiry_date)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000010U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  auto* released = _impl_.expiry_date_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.expiry_date_.Set("", GetArena());
  }
  return released;
}
inline void RestockItem::set_allocated_expiry_date(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  _impl_.expiry_date_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.expiry_date_.IsDefault()) {
    _impl_.expiry_date_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:inventory.RestockItem.expiry_date)
}

// -------------------------------------------------------------------

// RestockItemsResponse

// bool success = 1;
inline void RestockItemsResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline bool RestockItemsResponse::success() const {
  // @@protoc_insertion_point(field_get:inventory.RestockItemsResponse.success)
  return _internal_success();
}
inline void RestockItemsResponse::set_success(bool value) {
  _internal_set_success(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:inventory.RestockItemsResponse.success)
}
inline bool RestockItemsResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void RestockItemsResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ReportJobStatusRequest

// string order_id = 1;
inline void ReportJobStatusRequest::clear_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.order_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& ReportJobStatusRequest::order_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.ReportJobStatusRequest.order_id)
  return _internal_order_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ReportJobStatusRequest::set_order_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.order_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:inventory.ReportJobStatusRequest.order_id)
}
inline ::std::string* PROTOBUF_NONNULL ReportJobStatusRequest::mutable_order_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_order_id();
  // @@protoc_insertion_point(field_mutable:inventory.ReportJobStatusRequest.order_id)
  return _s;
}
inline const ::std::string& ReportJobStatusRequest::_internal_order_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.order_id_.Get();
}
inline void ReportJobStatusRequest::_internal_set_order_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.order_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ReportJobStatusRequest::_internal_mutable_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.order_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ReportJobStatusRequest::release_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:inventory.ReportJobStatusRequest.order_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.order_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.order_id_.Set("", GetArena());
  }
  return released;
}
inline void ReportJobStatusRequest::set_allocated_order_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.order_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.order_id_.IsDefault()) {
    _impl_.order_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:inventory.ReportJobStatusRequest.order_id)
}

// string robot_id = 2;
inline void ReportJobStatusRequest::clear_robot_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.robot_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& ReportJobStatusRequest::robot_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.ReportJobStatusRequest.robot_id)
  return _internal_robot_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ReportJobStatusRequest::set_robot_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.robot_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:inventory.ReportJobStatusRequest.robot_id)
}
inline ::std::string* PROTOBUF_NONNULL ReportJobStatusRequest::mutable_robot_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_robot_id();
  // @@protoc_insertion_point(field_mutable:inventory.ReportJobStatusRequest.robot_id)
  return _s;
}
inline const ::std::string& ReportJobStatusRequest::_internal_robot_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.robot_id_.Get();
}
inline void ReportJobStatusRequest::_internal_set_robot_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.robot_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ReportJobStatusRequest::_internal_mutable_robot_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.robot_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ReportJobStatusRequest::release_robot_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:inventory.ReportJobStatusRequest.robot_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.robot_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.robot_id_.Set("", GetArena());
  }
  return released;
}
inline void ReportJobStatusRequest::set_allocated_robot_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.robot_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.robot_id_.IsDefault()) {
    _impl_.robot_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:inventory.ReportJobStatusRequest.robot_id)
}

// string status = 3;
inline void ReportJobStatusRequest::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::std::string& ReportJobStatusRequest::status() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.ReportJobStatusRequest.status)
  return _internal_status();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ReportJobStatusRequest::set_status(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  _impl_.status_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:inventory.ReportJobStatusRequest.status)
}
inline ::std::string* PROTOBUF_NONNULL ReportJobStatusRequest::mutable_status()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:inventory.ReportJobStatusRequest.status)
  return _s;
}
inline const ::std::string& ReportJobStatusRequest::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.status_.Get();
}
inline void ReportJobStatusRequest::_internal_set_status(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ReportJobStatusRequest::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.status_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ReportJobStatusRequest::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:inventory.ReportJobStatusRequest.status)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000004U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  auto* released = _impl_.status_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.status_.Set("", GetArena());
  }
  return released;
}
inline void ReportJobStatusRequest::set_allocated_status(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  _impl_.status_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:inventory.ReportJobStatusRequest.status)
}

// map<string, int32> items = 4;
inline int ReportJobStatusRequest::_internal_items_size() const {
  return _internal_items().size();
}
inline int ReportJobStatusRequest::items_size() const {
  return _internal_items_size();
}
inline void ReportJobStatusRequest::clear_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.items_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::google::protobuf::Map<::std::string, ::int32_t>& ReportJobStatusRequest::_internal_items() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.items_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::int32_t>& ReportJobStatusRequest::items() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:inventory.ReportJobStatusRequest.items)
  return _internal_items();
}
inline ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL ReportJobStatusRequest::_internal_mutable_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.items_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL ReportJobStatusRequest::mutable_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_mutable_map:inventory.ReportJobStatusRequest.items)
  return _internal_mutable_items();
}

// -------------------------------------------------------------------

// ReportJobStatusResponse

// bool success = 1;
inline void ReportJobStatusResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline bool ReportJobStatusResponse::success() const {
  // @@protoc_insertion_point(field_get:inventory.ReportJobStatusResponse.success)
  return _internal_success();
}
inline void ReportJobStatusResponse::set_success(bool value) {
  _internal_set_success(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:inventory.ReportJobStatusResponse.success)
}
inline bool ReportJobStatusResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void ReportJobStatusResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CheckoutRequest

// string order_id = 1;
inline void CheckoutRequest::clear_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.order_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& CheckoutRequest::order_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.CheckoutRequest.order_id)
  return _internal_order_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CheckoutRequest::set_order_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.order_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:inventory.CheckoutRequest.order_id)
}
inline ::std::string* PROTOBUF_NONNULL CheckoutRequest::mutable_order_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_order_id();
  // @@protoc_insertion_point(field_mutable:inventory.CheckoutRequest.order_id)
  return _s;
}
inline const ::std::string& CheckoutRequest::_internal_order_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.order_id_.Get();
}
inline void CheckoutRequest::_internal_set_order_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.order_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CheckoutRequest::_internal_mutable_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.order_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CheckoutRequest::release_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:inventory.CheckoutRequest.order_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.order_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.order_id_.Set("", GetArena());
  }
  return released;
}
inline void CheckoutRequest::set_allocated_order_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.order_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.order_id_.IsDefault()) {
    _impl_.order_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:inventory.CheckoutRequest.order_id)
}

// map<string, int32> items = 2;
inline int CheckoutRequest::_internal_items_size() const {
  return _internal_items().size();
}
inline int CheckoutRequest::items_size() const {
  return _internal_items_size();
}
inline void CheckoutRequest::clear_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.items_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::google::protobuf::Map<::std::string, ::int32_t>& CheckoutRequest::_internal_items() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.items_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::int32_t>& CheckoutRequest::items() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:inventory.CheckoutRequest.items)
  return _internal_items();
}
inline ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL CheckoutRequest::_internal_mutable_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.items_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL CheckoutRequest::mutable_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_map:inventory.CheckoutRequest.items)
  return _internal_mutable_items();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CheckoutResponse

// string order_id = 1;
inline void CheckoutResponse::clear_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.order_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& CheckoutResponse::order_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:inventory.CheckoutResponse.order_id)
  return _internal_order_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CheckoutResponse::set_order_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.order_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:inventory.CheckoutResponse.order_id)
}
inline ::std::string* PROTOBUF_NONNULL CheckoutResponse::mutable_order_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_order_id();
  // @@protoc_insertion_point(field_mutable:inventory.CheckoutResponse.order_id)
  return _s;
}
inline const ::std::string& CheckoutResponse::_internal_order_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.order_id_.Get();
}
inline void CheckoutResponse::_internal_set_order_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.order_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CheckoutResponse::_internal_mutable_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.order_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CheckoutResponse::release_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:inventory.CheckoutResponse.order_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.order_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.order_id_.Set("", GetArena());
  }
  return released;
}
inline void CheckoutResponse::set_allocated_order_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.order_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.order_id_.IsDefault()) {
    _impl_.order_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:inventory.CheckoutResponse.order_id)
}

// map<string, int32> items = 2;
inline int CheckoutResponse::_internal_items_size() const {
  return _internal_items().size();
}
inline int CheckoutResponse::items_size() const {
  return _internal_items_size();
}
inline void CheckoutResponse::clear_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.items_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::google::protobuf::Map<::std::string, ::int32_t>& CheckoutResponse::_internal_items() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.items_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::int32_t>& CheckoutResponse::items() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:inventory.CheckoutResponse.items)
  return _internal_items();
}
inline ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL CheckoutResponse::_internal_mutable_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.items_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::int32_t>* PROTOBUF_NONNULL CheckoutResponse::mutable_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_mutable_map:inventory.CheckoutResponse.items)
  return _internal_mutable_items();
}

// bool success = 3;
inline void CheckoutResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline bool CheckoutResponse::success() const {
  // @@protoc_insertion_point(field_get:inventory.CheckoutResponse.success)
  return _internal_success();
}
inline void CheckoutResponse::set_success(bool value) {
  _internal_set_success(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:inventory.CheckoutResponse.success)
}
inline bool CheckoutResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void CheckoutResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// double total_price = 4;
inline void CheckoutResponse::clear_total_price() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_price_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline double CheckoutResponse::total_price() const {
  // @@protoc_insertion_point(field_get:inventory.CheckoutResponse.total_price)
  return _internal_total_price();
}
inline void CheckoutResponse::set_total_price(double value) {
  _internal_set_total_price(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:inventory.CheckoutResponse.total_price)
}
inline double CheckoutResponse::_internal_total_price() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_price_;
}
inline void CheckoutResponse::_internal_set_total_price(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_price_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace inventory


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // inventory_2eproto_2epb_2eh
