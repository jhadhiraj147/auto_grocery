package mq

import (

	// This is the package generated by the flatc command above
	"auto_grocery/inventory/fbs/RobotMessages"

	flatbuffers "github.com/google/flatbuffers/go"
	zmq "github.com/pebbe/zmq4"
)

type Publisher struct {
	socket *zmq.Socket
}

func NewPublisher(port string) (*Publisher, error) {
	sock, err := zmq.NewSocket(zmq.Type(zmq.PUB))
	if err != nil {
		return nil, err
	}
	// Broadcasters "Bind" to a port
	addr := "tcp://*:" + port
	if err := sock.Bind(addr); err != nil {
		return nil, err
	}
	return &Publisher{socket: sock}, nil
}

// SendRobotCommand takes the Go map and packs it into a Flatbuffer binary blob
func (p *Publisher) SendRobotCommand(orderID string, items map[string]int32) error {
	builder := flatbuffers.NewBuilder(1024)

	// 1. Pack the Items into the Flatbuffer format
	var itemOffsets []flatbuffers.UOffsetT
	for sku, qty := range items {
		s := builder.CreateString(sku)
		
		RobotMessages.ItemStart(builder)
		RobotMessages.ItemAddSku(builder, s)
		RobotMessages.ItemAddQuantity(builder, qty)
		itemOffsets = append(itemOffsets, RobotMessages.ItemEnd(builder))
	}

	// 2. Create the Vector (Array) of items
	RobotMessages.OrderBroadcastStartItemsVector(builder, len(itemOffsets))
	for i := len(itemOffsets) - 1; i >= 0; i-- {
		builder.PrependUOffsetT(itemOffsets[i])
	}
	itemsVec := builder.EndVector(len(itemOffsets))

	// 3. Create the main OrderBroadcast object
	oid := builder.CreateString(orderID)
	RobotMessages.OrderBroadcastStart(builder)
	RobotMessages.OrderBroadcastAddOrderId(builder, oid)
	RobotMessages.OrderBroadcastAddItems(builder, itemsVec)
	order := RobotMessages.OrderBroadcastEnd(builder)

	// 4. Finalize the buffer
	builder.Finish(order)
	payload := builder.FinishedBytes()

	// 5. Broadcast the raw binary!
	_, err := p.socket.SendBytes(payload, 0)
	return err
}

func (p *Publisher) Close() {
	p.socket.Close()
}